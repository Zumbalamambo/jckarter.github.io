<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
<title>Durian Software: Joe's Blog</title>
<link>http://duriansoftware.com/joe/</link>
<description>Joe's blog.</description>
<language>en-us</language>
<item>
<title>Optimizing global constant data structures using relative references</title>
<link>http://duriansoftware.com/joe/Optimizing-global-constant-data-structures-using-relative-references.html</link>
<description>
Building a native compiler for a programming language with rich reflection? Runtime type information, method dispatch tables, and other metadata require complex data structures full of cross references between related language entities. To reduce the size, memory usage, and launch time cost of these pointer-heavy constant data structures, you can try building them out of &lt;b&gt;relative references&lt;/b&gt; instead of pointers. Pointers are one of C&#39;s defining features, and seemingly the simplest mechanism for building data structures, but they carry hidden costs when used in global constants, which we&#39;ll explore in this post and look at how we can avoid them. Even if you&#39;re not writing a compiler, understanding this optimization is a fun chance to peel back some of the mystique of C, explore a bit of the runtime machinery that makes C programs work in contemporary operating systems, and see how a compiler can make different tradeoffs when not constrained by the abstractions C provides. Most of what I&#39;ll describe here applies specifically to macOS, iOS, and Apple&#39;s other platforms, although ELF-based operating systems like Linux and FreeBSD on x86 work largely the same way. (Windows dynamic linking is very different in many ways, though this optimization still has benefits there.)

&lt;h3&gt;The hidden costs of global pointers&lt;/h3&gt;

The most common way to represent a C++-style vtable is something like this C structure:

&lt;pre&gt;
const struct object_vtable {
  const type_info *typeinfo;
  void (*method1)(object *self);
  void (*method2)(object *self, int argument);
  /* etc. */
} object_vtable = {
  .typeinfo = &amp;object_typeinfo,
  .method1 = &amp;object_method1,
  .method2 = &amp;object_method2,
  /* etc. */
};
&lt;/pre&gt;

And it&#39;s easy to believe this is the only way, since C is the &quot;bare metal&quot; language, and these are the tools C gives you to represent these kinds of data structures. The &lt;tt&gt;object_vtable&lt;/tt&gt; structure here is a global constant, full of pointers to other global constants&amp;mdash;it should be &quot;free&quot;, right? In reality, operating systems provide a fairly elaborate runtime environment in order to make C programs work. Data structures that contain global pointers will in fact allocate memory at program launch before even entering &lt;tt&gt;main()&lt;/tt&gt;. To understand why, we need to peek behind the scenes and look at how the dynamic linker works.

&lt;p&gt;
When a process is formed, the contents of the executable file and all of the dynamic libraries it uses get memory-mapped into the new process&#39;s address space by the dynamic linker. The dynamic linker uses the kernel&#39;s memory mapping feature to do this, associating regions of memory with the contents of the binary files on disk. As long as this memory isn&#39;t changed by the running program, the kernel can consider it to be &quot;clean&quot;, so that if the system needs to free up memory for other purposes, it can discard these clean pages and reload them from the original binary later, since they haven&#39;t been changed. Furthermore, if multiple processes launch using the same executable or dynamic libraries, the exact same clean memory pages can be shared across the addresses of all of those different processes, significantly reducing the amount of memory needed by the entire system.

&lt;p&gt;
However, for a number of reasons, the code and data in a binary on disk can&#39;t know for certain what memory address it&#39;s going to end up getting mapped to in a running process. Every executable can link against any set of dynamic libraries, so a dynamic library may have to rebase to make room for other libraries in the process. Also, as a layer of security, operating systems use &lt;b&gt;address space layout randomization&lt;/b&gt;, or ASLR, so that if a program gets exploited, attacker code can&#39;t make static assumptions about the location of other exploitable resources in the program&#39;s memory, making exploits harder to write. Because the binary on disk doesn&#39;t know what address it&#39;s going to be mapped to, when pointers appear in its global data, the dynamic linker has to &lt;b&gt;slide&lt;/b&gt; all of those pointers to their correct values for the process. This sliding has to happen when the program is loaded, before entering &lt;tt&gt;main&lt;/tt&gt;, delaying the launch of the program. It also causes the pages those pointers are on to become &quot;dirty&quot; from the kernel&#39;s perspective, causing the system to use more memory: dirty pages can&#39;t be shared among different processes, since the pointer values may be different in each process, and since they no longer match the contents of the binary on disk, they can no longer be merely discarded if the system needs to free up memory for other uses; dirty pages instead have to be written and reloaded from swap.

&lt;p&gt;
I wrote a &lt;a href=&quot;https://gist.github.com/jckarter/e134a24123d4db7cc68cf2890389f644&quot;&gt;small C program for macOS&lt;/a&gt; to observe the impact of global pointers on memory usage and program launch time. This program measures the current time and then spawns another copy of itself, which measures the time immediately after entering &lt;tt&gt;main&lt;/tt&gt; and reports the time difference in nanoseconds. The program also accepts a &lt;tt&gt;-stop&lt;/tt&gt; argument, which will cause the process to suspend itself immediately after reporting its launch time, allowing us to inspect its memory usage after entering &lt;tt&gt;main&lt;/tt&gt;. We can build it in three variants:

&lt;ul&gt;
&lt;li&gt;One without any global data structures,
&lt;li&gt;One with 256 kilobytes of non-pointer data structures,
&lt;li&gt;One with 256 kilobytes of pointers, resembling a C++-like set of class vtables.
&lt;/ul&gt;

We can build these three variants like this:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; xcrun clang -O3 -fpie lots-of-global-pointers.c -DVARIATION=0 -o no_class_records
&lt;b&gt;$&lt;/b&gt; xcrun clang -O3 -fpie lots-of-global-pointers.c -DVARIATION=1 -o non_pointer_class_records
&lt;b&gt;$&lt;/b&gt; xcrun clang -O3 -fpie lots-of-global-pointers.c -DVARIATION=2 -o pointer_class_records
&lt;/pre&gt;

I ran each variant a thousand times on my computer, a 3.1GHz 2017 15&quot; MacBook Pro, and I got these average timings:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; average() { awk &#39;{ sum += $0 } END { printf &quot;%u\n&quot;, sum / NR }&#39; }
&lt;b&gt;$&lt;/b&gt; (for i in $(seq 1 1000); do ./no_class_records; done) | average
&lt;b&gt;1513058&lt;/b&gt;
&lt;b&gt;$&lt;/b&gt; (for i in $(seq 1 1000); do ./non_pointer_class_records; done) | average
&lt;b&gt;1517911&lt;/b&gt;
&lt;b&gt;$&lt;/b&gt; (for i in $(seq 1 1000); do ./pointer_class_records; done) | average
&lt;b&gt;1712659&lt;/b&gt;
&lt;/pre&gt;

We can see that the global pointers in the &lt;tt&gt;pointer_class_records&lt;/tt&gt; variant have a small but measurable impact on its launch time&amp;mdash;about 0.2 milliseconds, or a 13% increase over the baseline launch time of 1.5 milliseconds. If I run each variant with the &lt;tt&gt;-stop&lt;/tt&gt; flag, and inspect the stopped processes&#39; memory usage, I see something like this:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; ./no_class_records -stop
2034244 nanoseconds from spawn to main() entry
pid 73439
zsh: suspended (signal)  ./no_class_records -stop

&lt;b&gt;$&lt;/b&gt; ./non_pointer_class_records -stop
2147981 nanoseconds from spawn to main() entry
pid 73519
zsh: suspended (signal)  ./non_pointer_class_records -stop

&lt;b&gt;$&lt;/b&gt; ./pointer_class_records -stop
2221860 nanoseconds from spawn to main() entry
pid 73528
zsh: suspended (signal)  ./pointer_class_records -stop

&lt;b&gt;$&lt;/b&gt; top -pid 73439 -pid 73519 -pid 73528
PID    COMMAND       ...  &lt;b&gt;MEM &lt;/b&gt;  ...
73528  pointer_clas  ...  &lt;b&gt;572K&lt;/b&gt;  ...
73519  non_pointer_  ...  &lt;b&gt;316K&lt;/b&gt;  ...
73439  no_class_rec  ...  &lt;b&gt;316K&lt;/b&gt;  ...
&lt;/pre&gt;

We can see that the &lt;tt&gt;no_class_records&lt;/tt&gt; and &lt;tt&gt;non_pointer_class_records&lt;/tt&gt; variants have no difference in memory usage, whereas the &lt;tt&gt;pointer_class_records&lt;/tt&gt; variant uses 256KB more memory, due to its global data getting dirtied by the dynamic linker&#39;s sliding.

&lt;p&gt;These costs may seem small, but in an operating system with frequently-used dynamic libraries that get loaded into almost every process, and executables that have many instances of the same binary running at the same time, the launch time and dirty page costs add up. On mobile platforms, where memory is constrained and swap is usually unavailable, dirty pages directly affect how many processes and how much user data can be kept in memory, and small-seeming changes in load times can have a big impact on the perceived responsiveness and performance of the platform.

&lt;h3&gt;Using relative references to build position-independent data structures&lt;/h3&gt;

How can we represent these reference-heavy data structures in a way that doesn&#39;t pay the load time and dirty page costs of global pointers? For inspiration, we can look at how compilers emit &lt;b&gt;position-independent code&lt;/b&gt;, or PIC, which is machine code that behaves the same way regardless of where it&#39;s loaded in memory. Machine code is full of references to represent branches, function calls, and reads or writes of global variables. Most contemporary CPU instruction sets let these operations be represented with &lt;b&gt;PC-relative addressing&lt;/b&gt; (&quot;PC&quot; being short for &quot;program counter&quot;, the address of the currently-executing instruction), meaning the thing being referenced is named by its &lt;b&gt;relative offset&lt;/b&gt; from the current instruction rather than by a pointer to its absolute address. Whereas absolute pointers change values when the binary gets mapped into memory at a different base address, the relative distances between data structures within the binary do not.
&lt;p&gt;
We can make data structures position-independent the same way code does, by having structures reference other binaries by their distance from each other within the binary instead of by their absolute addresses. For example, the &lt;tt&gt;object_vtable&lt;/tt&gt; from the beginning of the article could look something like this instead:

&lt;pre&gt;
#define OFFSET(target, source) \
  ((intptr_t)&amp;target - (intptr_t)&amp;source)

const struct object_vtable {
  int typeinfo_offset;
  int method1_offset;
  int method2_offset;
  /* etc. */
} object_vtable = {
  .typeinfo_offset = OFFSET(object_typeinfo, object_vtable.typeinfo_offset),
  .method1_offset = OFFSET(object_method1, object_vtable.method1_offset),
  .method2_offset = OFFSET(object_method2, object_vtable.method2_offset),
  /* etc. */
};
&lt;/pre&gt;

And since these relative distances between objects won&#39;t change regardless of where the binary gets mapped into memory, the pages they get loaded into will remain clean. Also, since executables are still normally limited to 2GB even on 64-bit platforms (unless they opt into special &quot;large code models&quot; that increase code size in order to allow the linker to resolve 64-bit addresses), there&#39;s an opportunity to reduce size too, since a relative reference to another global in the same binary can be four bytes instead of eight, halving the size of many data structures.

&lt;p&gt;
Unfortunately, C and C++ don&#39;t consider expressions involving subtracting global addresses to be constant expressions. If we try to compile something like the offset-based &lt;tt&gt;object_vtable&lt;/tt&gt; implementation above, we&#39;ll get an error:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; xcrun clang foo.c
foo.c:16:22: error: initializer element is not a compile-time constant
  .typeinfo_offset = OFFSET(object_typeinfo, object_vtable.typeinfo_offset),
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/pre&gt;

So to take advantage of this technique, we have to go deeper. Regardless of what C says, the underlying assembler and linker support this on most contemporary platforms, as does LLVM. Using the assembler on macOS, a data structure with relative references can be generated like this:

&lt;pre&gt;
.section __TEXT, __const    ; Put the following into the constants section of the binary
.global _object_vtable      ; Export the C symbol &#39;object_vtable&#39;
                            ; (C symbols begin with underscores in macOS assembly)
_object_vtable:             ; Define object_vtable
  .long _object_typeinfo - .    ; Emit the distance between object_typeinfo and here
                                ; (A &#39;.&#39; represents the current address in assembly)
  .long _object_method1 - .
  .long _object_method2 - .
&lt;/pre&gt;

The same thing can be expressed in LLVM with a somewhat verbose constant expression:

&lt;pre&gt;
%object_vtable = type { i32, i32, i32 }
%object_typeinfo = type opaque
%object_method = type opaque

@object_typeinfo = external constant %object_typeinfo
@object_method1 = external constant %object_method
@object_method2 = external constant %object_method
@object_vtable = constant %object_vtable {
  i32 trunc (i64 sub
    (i64 ptrtoint (%object_typeinfo* @object_typeinfo to i64),
     i64 ptrtoint (i32* getelementptr (%object_vtable, %object_vtable* @object_vtable, i32 0, i32 0) to i64)) to i32),
  i32 trunc (i64 sub
    (i64 ptrtoint (%object_method* @object_method1 to i64),
     i64 ptrtoint (i32* getelementptr (%object_vtable, %object_vtable* @object_vtable, i32 0, i32 1) to i64)) to i32),
  i32 trunc (i64 sub
    (i64 ptrtoint (%object_method* @object_method2 to i64),
     i64 ptrtoint (i32* getelementptr (%object_vtable, %object_vtable* @object_vtable, i32 0, i32 2) to i64)) to i32)
}
&lt;/pre&gt;

&lt;p&gt;One tradeoff to using relative references is that they do require slightly more generated code on average to dereference than absolute pointers, leading to small performance and code size costs. To explore these costs, &lt;a href=&quot;https://gist.github.com/jckarter/cbf260c32154847cf9bd718c797d2d15&quot;&gt;here&#39;s another small macOS C program&lt;/a&gt; that microbenchmarks absolute and relative references by creating a large number of vtables using either relative or absolute method pointers and measuring the time taken to call through them all. We can build both variations like this:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; xcrun clang -O3 -fpie invoking-relative-references.c -DVARIATION=0 -o relative
&lt;b&gt;$&lt;/b&gt; xcrun clang -O3 -fpie invoking-relative-references.c -DVARIATION=1 -o absolute
&lt;/pre&gt;

&lt;p&gt;And then run them:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; ./absolute
850393727 nanoseconds to invoke methods
&lt;b&gt;$&lt;/b&gt; ./relative
867976645 nanoseconds to invoke methods
&lt;/pre&gt;

This shows about a 2% cost for using relative references (if we&#39;re doing absolutely nothing but indirectly calling methods, which is an unlikely real-world workload). We can also compare other interesting things about the binaries, like total size:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; ls -l absolute relative
-rwxr-xr-x  1 joe  staff  &lt;b&gt;270872&lt;/b&gt; Feb 14 20:23 absolute*
-rwxr-xr-x  1 joe  staff  &lt;b&gt;139792&lt;/b&gt; Feb 14 20:45 relative*
&lt;/pre&gt;

The version with absolute pointers is almost twice the size, due to the vtables containing eight-byte pointers instead of four-byte relative offsets. We can also compare code size only, minus the data:

&lt;pre&gt;
&lt;b&gt;$&lt;/b&gt; objdump -section-headers absolute | grep __text                    
  0 __text        &lt;b&gt;000000e7&lt;/b&gt; 0000000100000e50 TEXT 
&lt;b&gt;$&lt;/b&gt; objdump -section-headers relative | grep __text
  0 __text        &lt;b&gt;0000010d&lt;/b&gt; 0000000100000e20 TEXT 
&lt;/pre&gt;

The code size for following relative references is higher by 38 bytes, 16% more than the absolute variant. All of these costs and benefits are exaggerated by this being an artificial benchmark that does nothing but follow references, but they give a sense of the tradeoffs involved. A real program will generally be doing a lot more between method calls or pointer dereferences, giving contemporary CPUs the opportunity to mask this cost by doing other operations simultaneously with the extra reference math. Nonetheless, for data structures that require maximum performance, the launch-time, dirty memory, and size costs of absolute pointers may still be worth paying to avoid the runtime cost. Otherwise, smaller is generally better, and code and static data is generally cheaper than dirty data at the system level, so optimizing to reduce the size of data, and particularly the amount of dirty data, is a good default stance.

&lt;h3&gt;Leveraging the dynamic linker&#39;s data structures for references across libraries&lt;/h3&gt;

Relative references can eliminate the launch-time and dirty memory overhead of global constant references when the source and target of the reference are both in the same dynamic library or executable. On the other hand, when a data structure needs to reference a symbol that comes from another dynamic library, some work at launch time is inevitable; after all, the whole point of the dynamic linker is to resolve references between independent binary files. Nonetheless, we can minimize the launch time and dirty memory cost of these references by reusing data structures that already get built to make dynamic linking work. When the compile-time linker builds an executable or dynamic library from &lt;tt&gt;.o&lt;/tt&gt; files, and the code in those files references global variables from other dynamic libraries, the linker builds a &lt;b&gt;global offset table&lt;/b&gt;, or GOT, with an entry for each external variable the binary references. You can think of each GOT entry as being an extra global variable that the dynamic linker fills in with the resolved address of its associated original variable. (This is in fact how you can work with the GOT from LLVM, which we&#39;ll get back to in a minute.) When code tries to read or write the variable, it first has to load the value of the GOT entry variable to get the variable&#39;s address. For instance, when the compiler generates assembly for the following C code:

&lt;pre&gt;
extern int some_variable;

int get_value_of_some_variable(void) {
  return some_variable;
}
&lt;/pre&gt;

it&#39;ll produce something like this assembly language:

&lt;pre&gt;
_get_value_of_some_variable:
  mov rax, some_variable@GOTPCREL[rip] ; load the address of some_variable from the GOT
  mov eax, [rax]                       ; load the value of some_variable
  ret                                  ; return it
&lt;/pre&gt;

The &lt;tt&gt;@GOTPCREL&lt;/tt&gt; notation instructs the assembler to calculate the relative offset from the current instruction to a variable&#39;s entry in the GOT. We can also build data structures that refer to external symbols using relative references to their global offset table entries. This gives most of the same benefits as relative referencing symbols within the same binary. A global pointer will end up dirtying the memory page it resides in, whether it points at a local or external symbol. Although the GOT itself will be dirtied when the dynamic linker fills it in with resolved addresses, the GOT entries appear together in one contiguous area of memory. When the pointers are scattered through our constant data structures, more memory pages will get dirtied overall than if the pointers are concentrated together in the GOT. Since a GOT entry gets formed for an external symbol anyway when it gets referenced from code, there&#39;s no additional cost if we reuse it for our data structures.
&lt;p&gt;
The same &lt;tt&gt;@GOTPCREL&lt;/tt&gt; syntax works for data as well as code in assembly language:

&lt;pre&gt;
.global _external_relative_reference
_external_relative_reference:
  ; Note that GOTPCREL measures the distance from the address at the end of the
  ; four-byte value rather than the beginning, since x86-64 does
  ; PC-relative addressing relative to the address of the following instruction.
  ; Adding 4 compensates for this offset.
  .long _external_global@GOTPCREL+4
&lt;/pre&gt;

LLVM doesn&#39;t directly let you manipulate the GOT, but if you define a private global constant containing the address of another variable, and give that constant the &lt;tt&gt;unnamed_addr&lt;/tt&gt; attribute (which tells LLVM that the address of the constant is not meaningful to the program, only its contents, allowing it to coalesce it with other constants containing the same value), then LLVM will cleverly let the linker-generated GOT entry stand in for that global variable. If you initialize another LLVM global variable with a relative reference to one of these &quot;GOT equivalent&quot; constants, LLVM will produce a &lt;tt&gt;@GOTPCREL&lt;/tt&gt; expression in assembly language. For example, try compiling this LLVM code:

&lt;pre&gt;
@external_global = external constant i32

; LLVM treats this global variable as a &quot;GOT equivalent&quot;, and will replace
; references to @got.external_global with GOT relocations for external_global
; when possible.
@got.external_global = private unnamed_addr constant i32* @external_global

@external_relative_reference = constant i32 trunc (i64 sub
  (i64 ptrtoint (i32** @got.external_global to i64),
   i64 ptrtoint (i32* @external_relative_reference to i64)) to i32)
&lt;/pre&gt;

We have two different strategies for referencing symbols now, one for referencing local objects in the same binary by relative reference to their direct address, and one for referencing external objects, by relative reference to their GOT entry. In some situations, maybe you only need to support referencing local objects, such as for references between data structures that always get generated together as part of the same binary, but what if you need to handle both internal and external references? How do we know which mechanism was used at runtime? There are a few choices here, with different tradeoffs:
&lt;p&gt;
First of all, we could uniformly reference all symbols by GOT entry, local and external. The GOT doesn&#39;t have to exclusively be for external references; if the linker sees a &lt;tt&gt;@GOTPCREL&lt;/tt&gt; reference to a local variable, it will obligingly create a GOT entry for it. Uniformly referencing all symbols by GOT allows code that follows the reference to remain branchless, since it can uniformly load the offset, then load the GOT entry to get the desired address. It also preserves the benefits that a data structure&#39;s inline storage can remain in clean memory and use four-byte offsets instead of potentially eight-byte pointers. On the other hand, it forces GOT entries to be created for local symbols that wouldn&#39;t otherwise need them, and makes following every reference require a two-load chain, whether local or external. The additional launch time and dirty cost of an additional GOT entry is negligible; however, the added GOT entries incur an indirect size cost for the data structures that demand them&amp;mdash;we save four bytes of inline storage using a relative reference over a pointer, but that&#39;d be offset by adding eight bytes for the otherwise unnecessary GOT entry. Furthermore, long load chains increase the latency of an operation, and going through the GOT adds a load to the chain necessary to follow a reference, since the CPU has to first load the offset, wait for the value to come from memory, then load the final address from the GOT. Since the GOT load is dependent on the offset load, the CPU can&#39;t do anything to parallelize this operation.
&lt;p&gt;
Contemporary CPUs have good branch predictors and depend on instruction-level parallelism for maximum performance, so if we can branch to avoid extending a load chain, it&#39;s often worth it. That suggests an alternative approach, where we distinguish local from external references somehow so we can avoid going through the GOT for local references. If our data structures are aligned to 2, 4, 8 byte boundaries, we could encode whether a reference is external by setting one of the low bits of the offset, which would normally always be zero. We can then check this bit and branch to do the extra dereference necessary to load the GOT entry only for an external symbol, something like this:

&lt;pre&gt;
const void *resolve_indirectable_relative_offset(const int *offset_ptr) {
  int offset = *offset_ptr;
  intptr_t resolved_addr = (intptr_t)offset_ptr + (offset &amp; ~1);
  // If the low bit is set, then the offset refers to a GOT entry, and we need to
  // load from there to get the resolved address.
  if (offset_value &amp; 1) {
    return *(const void *const *)resolved_addr;
  } else {
    return (const void *)resolved_addr;
  }
}
&lt;/pre&gt;

This increases the code size to follow a reference, but it&#39;s likely to be faster overall for local references, since they only need to wait on a single load to resolve, and the branch is likely to get predicted by the CPU. If traversal of the data structure is infrequent, or isolated to a handful of runtime functions, the code size cost is likely to be worth the performance benefits for local references. On the other hand, if you have to follow the reference frequently in code generated everywhere, like as part of method lookup from dispatch tables, the code size hit may be unacceptable. Also, when referencing things like strings or function pointers that don&#39;t normally have alignment guarantees, there are no unused bits in the offset to use for discriminating local from nonlocal references.
&lt;p&gt;
It&#39;s also possible to avoid the need for external references in some situations by generating an equivalent local definition and referencing that instead. The aforementioned two kinds of object, strings and functions, are prime candidates for this. It&#39;s uncommon to link strings from other binaries, since C compilers typically give every binary its own string table. For functions, instead of referencing an external function directly, it&#39;s possible to instead reference a local thunk that jumps to the external implementation. This duplication simplifies the reference mechanism, which now only has to worry about local relative references, but eats into the size savings we get from relative referencing.

&lt;h3&gt;When does using this technique make sense?&lt;/h3&gt;

Finally, we have the choice of not using relative references at all, and just building data structures with pointers. Now that we&#39;ve established the costs and potential savings from using relative references instead of absolute pointers, let&#39;s think about when it makes sense to use them. Although global pointers dirty memory and require launch-time work to initialize, once they&#39;re set up, they&#39;re still the absolute cheapest kind of reference to resolve, for either local or external references. For data structures that are frequently accessed on hot paths, paying those one-time costs may be worth it. Relative references in global data are also not expressible in standard C or C++, making them difficult to adopt and maintain in a C or C++ program. Furthermore, the two major benefits of relative references, no launch time or dirty memory cost, are really only a factor for data that can be memory-mapped from disk. This is great for data structures that get compiled into the binary, or that can be memory-mapped from data files, but data structures that are built dynamically by the running program are going to have to allocate the memory and spend the time to initialize that memory no matter what. Relative referencing may still be useful as a size optimization for dynamically-generated data, but it doesn&#39;t offer the same major system performance advantages for dynamic data that it does for static global data. On the other hand, if that dynamic data structure is going to be memory-mapped or copied into other processes, serialized to disk and reloaded later, or sent to GPUs or other compute devices, relative referencing can still be a benefit, since the position-independent nature of relative references means they remain valid even if a memory region is transported to a different process, device, or file.
&lt;p&gt;
For some examples of data structures using relative references being used in practice, look at the &lt;a href=&quot;https://github.com/apple/swift/blob/master/include/swift/Runtime/Metadata.h&quot;&gt;Swift programming language runtime&lt;/a&gt;, which uses this technique extensively with its reflection data structures, enabling a Swift program to include a lot of runtime metadata without that metadata impacting the launch time or memory usage of the program. This technique has &lt;a href=&quot;https://groups.google.com/a/chromium.org/forum/#!topic/chromium-dev/774FO8shGw4&quot;&gt;also been implemented in the Clang C++ compiler&lt;/a&gt;, allowing it to emit C++ vtables using relative references, an option Chromium uses to reduce the size, launch time, and memory cost of all of the vtables from their gigantic C++ codebase. If you&#39;re working on a language runtime in a similar vein, it&#39;s a good technique to consider adopting for your compiler-generated data structures as well.

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2018-02-18T02:39:36+00:00</dc:date>
<guid>http://duriansoftware.com/joe/Optimizing-global-constant-data-structures-using-relative-references.html</guid>
</item>
<item>
<title>Self-aware struct-like types in C++11</title>
<link>http://duriansoftware.com/joe/Self-aware-struct-like-types-in-C++11.html</link>
<description>
&lt;p&gt;
Even with C++11, C++ offers inadequate metaprogramming facilities for user-defined types compared
to other programming languages.  Given an arbitrary struct type, you can&#39;t iterate its fields and
get useful information like name, offset, and size, without implementing those facilities by hand.
(Nearly every would-be C++ replacement language fixes this, but they
unfortunately aren&#39;t always viable options.)
The C++11 standard library introduced the &lt;tt&gt;tuple&lt;/tt&gt; template as a general-purpose
metaprogrammable composite type, but it sucks in a number of ways:
&lt;ul&gt;
&lt;li&gt;The user interface is awkward. Fields are unnamed and require integer indexing using a top-level template function, &lt;tt&gt;get&amp;lt;N&amp;gt;(tuple)&lt;/tt&gt; instead of &lt;tt&gt;struct.fieldname&lt;/tt&gt;.
&lt;li&gt;The implementation is not straightforward: &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/include/tuple&quot;&gt;libc++&#39;s &lt;tt&gt;tuple&lt;/tt&gt; header&lt;/a&gt; is 1054 lines, and &lt;a href=&quot;http://gcc.gnu.org/viewcvs/trunk/libstdc%2B%2B-v3/include/std/tuple?revision=188636&amp;view=markup&quot;&gt;libstdc++&#39;s&lt;/a&gt; is 1100, and both implementations rely on several layers of internal base classes to form the user-facing &lt;tt&gt;tuple&lt;/tt&gt; type.
&lt;li&gt;Useful techniques like &lt;a href=&quot;http://stackoverflow.com/questions/7858817/unpacking-a-tuple-to-call-a-matching-function-pointer&quot;&gt;passing unpacked tuple elements to a function&lt;/a&gt; are awkward to implement.
&lt;li&gt;&lt;tt&gt;tuple&lt;/tt&gt; as specified by the standard doesn&#39;t provide &lt;tt&gt;constexpr&lt;/tt&gt; elementwise construction or field access and can&#39;t be used in compile-time calculations.
&lt;/ul&gt;
&lt;p&gt;Here&#39;s an alternative approach I came up with that provides a user interface nearly equivalent to primitive structs, is much easier to metaprogram with than &lt;tt&gt;tuple&lt;/tt&gt;, and is easier to implement as well, requiring about 150 lines of header-only code.
I&#39;ve put a sample implementation up on Github at &lt;a href=&quot;https://github.com/jckarter/selfaware&quot;&gt;https://&lt;wbr&gt;github.com/&lt;wbr&gt;jckarter/&lt;wbr&gt;selfaware&lt;/a&gt;. Here&#39;s a rundown of how it works.
&lt;h3&gt;Self-aware field templates&lt;/h3&gt;
&lt;p&gt;The main idea is to inherit the &quot;struct&quot; type from a set of field class templates, each of which defines a single field along with methods to generically access its name string, value, and type. For example, a field template named &lt;tt&gt;foo&lt;/tt&gt; looks like this:
&lt;pre&gt;template&amp;lt;typename T&gt;
struct foo {
    T foo;

    // field name
    constexpr static char const *name() { return &quot;foo&quot;; }

    // field type
    using type = T;

    // field value generic accessor
    T &amp;amp;value() &amp;amp; { return this-&gt;foo; }
    T const &amp;amp;value() const &amp;amp; { return this-&gt;foo; }
    T &amp;amp;&amp;amp;value() &amp;amp;&amp;amp; { return this-&gt;foo; }
};&lt;/pre&gt;
&lt;p&gt;A preprocessor macro can generate these for us:
&lt;pre&gt;#define SELFAWARE_IDENTIFIER(NAME) \
    template&amp;lt;typename T&gt; \
    struct NAME { \
        T NAME; \
        // field name \
        constexpr static char const *name() { return #NAME; } \
        // field type \
        using type = T; \
        // field value generic accessor \
        T &amp;amp;value() &amp;amp; { return this-&gt;NAME; } \
        T const &amp;amp;value() const &amp;amp; { return this-&gt;NAME; } \
        T &amp;amp;&amp;amp;value() &amp;amp;&amp;amp; { return this-&gt;NAME; } \
    };&lt;/pre&gt;
&lt;h3&gt;The self-aware struct template&lt;/h3&gt;
&lt;p&gt;The &quot;struct&quot; template now needs only to inherit a set of field template instances and provide some
constructors:
&lt;pre&gt;template&amp;lt;typename...Fields&gt;
struct Struct : Fields... {
    // A convenience alias for subclasses
    using struct_type = Struct;

    // Preserve default constructors
    Struct() = default;
    Struct(Struct const &amp;amp;) = default;

    // Forwarding elementwise constructor
    template&amp;lt;typename...T&gt;
    constexpr Struct(T &amp;amp;&amp;amp;...x) : Fields{static_cast&amp;lt;T&amp;amp;&amp;amp;&gt;(x)}... {}
};&lt;/pre&gt;
&lt;p&gt;A &lt;tt&gt;Struct&lt;/tt&gt; type can then be used either by aliasing a &lt;tt&gt;Struct&lt;/tt&gt; instance or by
inheriting an instance and its constructors.
(As of Clang 3.1 and GCC 4.7, neither compiler yet supports inheriting constructors, so
aliasing is currently more practical.)
&lt;pre&gt;SELFAWARE_IDENTIFIER(foo)
SELFAWARE_IDENTIFIER(bar)
// Aliasing a Struct instance
using FooBar = Struct&amp;lt;foo&amp;lt;int&gt;, bar&amp;lt;double&gt;&gt;;
// Inheriting a Struct instance (requires inheriting constructors)
struct FooBar2 : Struct&amp;lt;foo&amp;lt;int&gt;, bar&amp;lt;double&gt;&gt; { using struct_type::struct_type; };&lt;/pre&gt;
&lt;p&gt;Values of the type look like normal structs to user code:
&lt;pre&gt;FooBar frob(int x) {
    FooBar f = {x, 0.0};
    f.foo += 1;
    f.bar += 1.0;
    return f;
}&lt;/pre&gt;
&lt;p&gt;The type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/types/is_trivial&quot;&gt;trivial&lt;/a&gt; if its component types are trivial, and its instances can be used in compile-time calculations if its component types can, like primitive structs. (However, because it inherits
multiple nonempty types, it&#39;s not &lt;a href=&quot;http://en.cppreference.com/w/cpp/types/is_standard_layout&quot;&gt;standard-layout&lt;/a&gt;, and thus not quite POD.)
&lt;pre&gt;static_assert(std::is_trivial&amp;lt;FooBar&gt;::value, &quot;should be trivial&quot;);
static_assert(FooBar{2, 3.0}.foo + FooBar{2, 4.0}.foo == 4, &quot;2 + 2 == 4&quot;);&lt;/pre&gt;
&lt;h3&gt;Metaprogramming with self-aware structs&lt;/h3&gt;
&lt;p&gt;Since the fields of the &lt;tt&gt;Struct&lt;/tt&gt; template are encoded in a template parameter pack,
there&#39;s a lot you can do to it with unpack expressions and recursive templates. Here are a few
examples:

&lt;h3&gt;Function application&lt;/h3&gt;
&lt;p&gt;Applying a function object
to a &lt;tt&gt;Struct&lt;/tt&gt;&#39;s unpacked fields is easy&amp;mdash;just unpack the &lt;tt&gt;value()&lt;/tt&gt; method
of each field superclass into a function call expression:
&lt;pre&gt;template&amp;lt;typename Function, typename...Fields&gt;
auto apply(Function &amp;amp;&amp;amp;f, Struct&amp;lt;Fields...&gt; const &amp;amp;a_struct)
    -&gt; decltype(f(a_struct.Fields::value()...))
{
    return f(a_struct.Fields::value()...);
}

double hypotenuse(double x, double y) { return sqrt(x*x, y*y); }

double fooBarHypotenuse(FooBar const &amp;amp;x) { return apply(hypotenuse, x); }&lt;/pre&gt;

&lt;h3&gt;Interop with &lt;tt&gt;tuple&lt;/tt&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;tt&gt;Struct&lt;/tt&gt; can be converted into a &lt;tt&gt;tuple&lt;/tt&gt; or &lt;tt&gt;tie&lt;/tt&gt; similarly:
&lt;pre&gt;template&amp;lt;typename...Fields&gt;
auto structToTuple(Struct&amp;lt;Fields...&gt; const &amp;amp;s)
    -&gt; std::tuple&amp;lt;typename Fields::type...&gt;
{
    return std::make_tuple(s.Fields::value()...);
}
template&amp;lt;typename...Fields&gt;
void assignStructFromTuple(Struct&amp;lt;Fields...&gt; &amp;amp;s,
                           std::tuple&amp;lt;typename Fields::type...&gt; const &amp;amp;t)
{
    std::tie(s.Fields::value()...) = t;
}&lt;/pre&gt;

&lt;h3&gt;Generating code from field metadata&lt;/h3&gt;
&lt;p&gt;The &lt;tt&gt;Struct&lt;/tt&gt; template can implement a static method to iterate through its fields,
passing the name string, offset, size, and type of each field to a function object in turn.
(Getting the offset unfortunately relies on undefined behavior, because C++11 restricts
&lt;tt&gt;offsetof&lt;/tt&gt; to standard-layout types and provides no other well-defined means that
I know of for determining offsets independent of an instance.)

&lt;pre&gt;template&amp;lt;typename...Fields&gt;
struct Struct : Fields... {
    // ... see above ...

    // NB: relies on undefined behavior
    template&amp;lt;typename Field&gt;
    static std::uintptr_t offset_of() {
        return reinterpret_cast&amp;lt;std::uintptr_t&gt;(&amp;amp;static_cast&amp;lt;Struct*&gt;(nullptr)-&gt;Field::value());
    }

    template&amp;lt;template&amp;lt;typename T&gt; class Trait, typename Function&gt;
    static void each_field(Function &amp;amp;&amp;amp;f)
    {
        // Unpack expressions are only allowed in argument lists and initialization lists,
        // so this expression unpacks the function call expression into the initializer list
        // for an unused array (which the optimizer is nice enough to discard)
        char pass[] = {
            (f(Fields::name(), offset_of&amp;lt;Fields&gt;(), sizeof(typename Fields::type),
              Trait&amp;lt;typename Fields::type&gt;::value()), &#39;\0&#39;)...};
        (void)pass; // suppress unused variable warnings
    }
};&lt;/pre&gt;

&lt;p&gt;Many libraries that deal with binary data have finicky APIs for describing struct layouts.
A good example is OpenGL&#39;s &lt;a href=&quot;http://www.opengl.org/sdk/docs/man4/&quot;&gt;&lt;tt&gt;gl&lt;wbr&gt;Vertex&lt;wbr&gt;Attrib&lt;wbr&gt;Pointer&lt;/tt&gt;&lt;/a&gt; interface, which is used to describe
the format of vertex information in memory. The &lt;tt&gt;each_field&lt;/tt&gt;
function template, paired with a traits class, can generate the correct sequence of
&lt;tt&gt;gl&lt;wbr&gt;Vertex&lt;wbr&gt;Attrib&lt;wbr&gt;Pointer&lt;/tt&gt; automatically from a &lt;tt&gt;Struct&lt;/tt&gt; instance&#39;s metadata:

&lt;pre&gt;struct GLVertexType { GLuint size; GLenum type; GLboolean normalized; };

// A trait class to provide glVertexAttribPointer arguments appropriate for a type
template&amp;lt;typename&gt; struct GLVertexTraits;
template&amp;lt;GLuint N&gt;
struct GLVertexTraits&amp;lt;float[N]&gt; {
    static GLVertexType value() { return {N, GL_FLOAT, GL_FALSE}; }
};
template&amp;lt;GLuint N&gt;
struct GLVertexTraits&amp;lt;std::uint8_t[N]&gt; {
    static GLVertexType value() { return {N, GL_UNSIGNED_BYTE, GL_TRUE}; }
};

template&amp;lt;typename Struct&gt;
bool bindVertexAttributes(GLuint program)
{
    _VertexAttributeBinder iter(program, sizeof(T));
    Struct::template each_field&amp;lt;GLVertexTraits&gt;(
        [=program](char const *name, size_t offset, size_t size, GLVertexType info) {
            GLint location = glGetAttribLocation(program, name);
            glVertexAttribPointer(location, info.size, info.type, info.normalized,
                                  sizeof(Struct), reinterpret_cast&amp;lt;const GLvoid*&gt;(offset));
            glEnableVertexAttribArray(location);
        });
    return iter.ok;
}&lt;/pre&gt;

&lt;h3&gt;Selecting a field at runtime by string name&lt;/h3&gt;
&lt;p&gt;A recursive template can generate code to pick a field at runtime from a string argument, passing the value through a function object to narrow the return type:&lt;/p&gt;
&lt;pre&gt;template&amp;lt;typename R, typename Field, typename...Fields, typename Visitor, typename...AllFields&gt;
R _select_field(Visitor &amp;amp;&amp;amp;v, char const *name, Struct&amp;lt;AllFields...&gt; const &amp;amp;a_struct)
{
    if (strcmp(name, Field::name()) == 0)
        return v(a_struct.Field::value());
    else
        return _select_field&amp;lt;R, Fields...&gt;(static_cast&amp;lt;Visitor&amp;amp;&amp;amp;&gt;(v), name, a_struct);
}

template&amp;lt;typename R, typename Visitor, typename...AllFields&gt;
R _select_field(Visitor &amp;amp;&amp;amp;v, char const *name, Struct&amp;lt;AllFields...&gt; const &amp;amp;a_struct)
{
    throw std::runtime_error(&quot;bad field name&quot;);
}

template&amp;lt;typename Visitor, typename Field, typename...AllFields&gt;
auto select_field(Visitor &amp;amp;&amp;amp;v, char const *name, Struct&amp;lt;Field, AllFields...&gt; const &amp;amp;a_struct)
    -&gt; decltype(v(a_struct.Field::value()))
{
    return _select_field&amp;lt;decltype(v(a_struct.Field::value())), Field, AllFields...&gt;
        (static_cast&amp;lt;Visitor&amp;amp;&amp;amp;&gt;(v), name, a_struct);
}&lt;/pre&gt;

&lt;tt&gt;select_field&lt;/tt&gt; can then be used like this:

&lt;pre&gt;template&amp;lt;typename T&gt;
struct converter {
    template&amp;lt;typename U&gt; T operator()(U &amp;amp;&amp;amp;x) { return T(x); }
};

void testStructSelectField()
{
    FooBar x{11, 22.0};

    double foo = select_field(converter&amp;lt;double&gt;(), &quot;foo&quot;, x);
    double bar = select_field(converter&amp;lt;double&gt;(), &quot;bar&quot;, x);
    assert(foo == 11.0);
    assert(bar == 22.0);
}&lt;/pre&gt;

&lt;h3&gt;Problems&lt;/h3&gt;
&lt;p&gt;This technique still isn&#39;t ideal. Most obviously, field templates all need to be
defined somewhere, which adds maintenance friction, and they rely on unseemly preprocessor magic
to create. Fields and &lt;tt&gt;Struct&lt;/tt&gt; instances could
perhaps be instantiated together in one macro, perhaps by pulling in &lt;tt&gt;boost::preprocessor&lt;/tt&gt;.
Compile time, always an issue with C++, also suffers from use of the &lt;tt&gt;Struct&lt;/tt&gt; template. Clang 3.1 takes almost a second on this 2.4 GHz Core 2 Duo just to compile the 199-line &lt;a href=&quot;https://github.com/jckarter/selfaware/blob/master/selfaware-test.cpp&quot;&gt;&lt;tt&gt;selfaware-test.cpp&lt;/tt&gt;&lt;/a&gt; test suite. And &lt;tt&gt;tuple&lt;/tt&gt;, for all its faults, is standard, and will be available on any platform
that purports to support C++11. Neither &lt;tt&gt;Struct&lt;/tt&gt; nor &lt;tt&gt;tuple&lt;/tt&gt; is standard-layout and
thus can&#39;t interoperate with C in a standard-guaranteed, portable way. I&#39;d love to hear about other
approaches to enabling composite type metaprogramming in C++.


</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2012-07-05T18:49:30+00:00</dc:date>
<guid>http://duriansoftware.com/joe/Self-aware-struct-like-types-in-C++11.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 4: Rendering a Dynamic 3D Scene with Phong Shading</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html&quot;&gt;&amp;laquo; Chapter 3&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;At this point, we&#39;ve seen the most important core parts of the OpenGL API and gotten a decent taste of the GLSL language. Now&#39;s a good time to start exercising OpenGL and implementing some graphic effects, introducing new nuances and specialized features of OpenGL and GLSL as we go. For the next few chapters, I&#39;ve prepared a new demo program you can get from my Github &lt;a href=&quot;http://github.com/jckarter/ch4-flag&quot;&gt;&lt;tt&gt;ch4-flag&lt;/tt&gt; repository&lt;/a&gt;. The &lt;tt&gt;flag&lt;/tt&gt; demo renders a waving flag on a flagpole against a simple background:
&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl4-flag.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
With the flat, wallpaper-looking grass and brick textures and the unnatural lack of shadow cast by the flag, it looks like something a Nintendo 64 would have rendered, but it&#39;s a start. We&#39;ll improve the graphical fidelity of the demo over the next few chapters. For this chapter, we&#39;ll render the above image by implementing the &lt;a href=&quot;http://en.wikipedia.org/wiki/Phong_shading&quot;&gt;&lt;b&gt;Phong shading&lt;/b&gt;&lt;/a&gt; model, which will serve as the basis for more advanced effects we&#39;ll look at later on.
&lt;/p&gt;
&lt;h3&gt;Overview of the &lt;tt&gt;flag&lt;/tt&gt; program&lt;/h3&gt;
&lt;p&gt;
I&#39;ve organized &lt;tt&gt;flag&lt;/tt&gt; into four C files and four headers. You&#39;ve already seen a good amount of it in &lt;tt&gt;hello-gl&lt;/tt&gt;: the &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/file-util.c&quot;&gt;&lt;tt&gt;file-util.c&lt;/tt&gt;&lt;/a&gt; and &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/file-util.h&quot;&gt;&lt;tt&gt;file-util.h&lt;/tt&gt;&lt;/a&gt; files contain the &lt;tt&gt;read_tga&lt;/tt&gt; and &lt;tt&gt;file_contents&lt;/tt&gt; functions, and &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/gl-util.c&quot;&gt;&lt;tt&gt;gl-util.c&lt;/tt&gt;&lt;/a&gt; and &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/gl-util.h&quot;&gt;&lt;tt&gt;gl-util.h&lt;/tt&gt;&lt;/a&gt; contain the &lt;tt&gt;make_texture&lt;/tt&gt;, &lt;tt&gt;make_shader&lt;/tt&gt;, and &lt;tt&gt;make_program&lt;/tt&gt; functions we wrote in chapter 2. The &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/gl-util.h&quot;&gt;&lt;tt&gt;vec-util.h&lt;/tt&gt;&lt;/a&gt; header contains some basic vector math functions. &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/flag.c&quot;&gt;&lt;tt&gt;flag.c&lt;/tt&gt;&lt;/a&gt; looks a lot like &lt;tt&gt;hello-gl.c&lt;/tt&gt; did: in &lt;tt&gt;main&lt;/tt&gt;, we initialize GLUT and GLEW, set up callbacks for GLUT events, call a &lt;tt&gt;make_resources&lt;/tt&gt; function to allocate a bunch of GL resources, and call out to &lt;tt&gt;glutMainLoop&lt;/tt&gt; to start running the demo. However, the setup and rendering are a bit more involved than last time. Let&#39;s look at what&#39;s new and changed:
&lt;/p&gt;
&lt;h3&gt;Mesh construction&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-mesh-01.png&quot;&gt;
&lt;p&gt;
The &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/meshes.c&quot;&gt;&lt;tt&gt;meshes.c&lt;/tt&gt;&lt;/a&gt; file contains code that generates the vertex and element arrays, collectively called a &lt;b&gt;mesh&lt;/b&gt;, for the flag, flagpole, ground, and wall objects that we&#39;ll be rendering. Most objects in the real world, including real flagpoles and flags, have smooth curving surfaces, but graphics cards deal with triangles. To render these objects, we have to approximate their surfaces as a collection of triangles. We do this by filling a vertex array with vertices placed along its surface, storing attributes of the surface with each vertex, and connecting the samples into triangles using the element array to give an approximation of the original surface.
&lt;/p&gt;
&lt;p&gt;The fundamental properties a mesh stores for each vertex are its &lt;b&gt;position&lt;/b&gt; in world space and its &lt;b&gt;normal&lt;/b&gt;, a vector perpendicular to the original surface. The normal is fundamental to shading calculations, as we&#39;ll see shortly. Normals should be &lt;b&gt;unit vectors&lt;/b&gt;, that is, vectors whose length is one. Each vertex also has &lt;b&gt;material&lt;/b&gt; parameters that indicate how the surface is shaded. The material can consist of a set of per-vertex values, &lt;b&gt;texture coordinates&lt;/b&gt; that sample material information from a texture, or some combination of both. &lt;p&gt;For the &lt;tt&gt;flag&lt;/tt&gt; demo, the material consists of a &lt;b&gt;texture coordinate&lt;/b&gt; for sampling the &lt;b&gt;diffuse&lt;/b&gt; color from the mesh texture, a &lt;b&gt;specular&lt;/b&gt; color, and &lt;b&gt;shininess&lt;/b&gt; factor. We&#39;ll see how these parameters are used shortly. Our vertex buffer thus contains an array of &lt;tt&gt;flag_vertex&lt;/tt&gt; structs looking like this:&lt;/p&gt;
&lt;pre&gt;struct flag_vertex {
    GLfloat position[4];
    GLfloat normal[4];
    GLfloat texcoord[2];
    GLfloat shininess;
    GLubyte specular[4];
};&lt;/pre&gt;
&lt;p&gt;Although the position and normal are three-dimensional vectors, we pad them out to four elements because most GPUs prefer to load vector data from 128-bit-aligned buffers, like SIMD instruction sets such as SSE. For each mesh, we collect the vertex buffer, element buffer, texture object, and element count into a &lt;tt&gt;flag_mesh&lt;/tt&gt; struct. When we render, we set up &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt;s to pass all of the &lt;tt&gt;flag_vertex&lt;/tt&gt; attributes to the vertex shader:&lt;/p&gt;
&lt;pre&gt; struct flag_mesh {
    GLuint vertex_buffer, element_buffer;
    GLsizei element_count;
    GLuint texture;
};&lt;/pre&gt;
&lt;pre&gt;static void render_mesh(struct flag_mesh const *mesh)
{
    glBindTexture(GL_TEXTURE_2D, mesh-&gt;texture);

    glBindBuffer(GL_ARRAY_BUFFER, mesh-&gt;vertex_buffer);
    glVertexAttribPointer(
        g_resources.flag_program.attributes.position,
        3, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, position)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.normal,
        3, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, normal)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.texcoord,
        2, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, texcoord)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.shininess,
        1, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, shininess)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.specular,
        4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, specular)
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh-&gt;element_buffer);
    glDrawElements(
        GL_TRIANGLES,
        mesh-&gt;element_count,
        GL_UNSIGNED_SHORT,
        (void*)0
    );
}&lt;/pre&gt;
&lt;p&gt;Note that the &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt; call for the &lt;tt&gt;specular&lt;/tt&gt; color attribute passes &lt;tt&gt;GL_TRUE&lt;/tt&gt; for the &lt;i&gt;normalized&lt;/i&gt; argument. The specular colors are stored as four-component arrays of bytes between &lt;tt&gt;0&lt;/tt&gt; and &lt;tt&gt;255&lt;/tt&gt;, much as they would be in a bitmap image, but with the normalized flag set, they&#39;ll be presented to the shaders as normalized floating-point values between &lt;tt&gt;0.0&lt;/tt&gt; and &lt;tt&gt;1.0&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The actual code to generate the meshes is fairly tedious, so I&#39;ll just describe it at a high level. We construct two distinct meshes: the background mesh, created by &lt;tt&gt;init_background_mesh&lt;/tt&gt;, which consists of the static flagpole, ground, and wall objects; and the flag, set up by &lt;tt&gt;init_flag_mesh&lt;/tt&gt;. The background mesh consists of two large rectangles for the ground and wall, and a thin cylinder with a pointed truck making the flagpole. The wall, ground, and flagpole are assigned texture coordinates to sample out of a single &lt;b&gt;texture atlas&lt;/b&gt; image containing the grass, brick, and metal textures, stored in &lt;tt&gt;background.tga&lt;/tt&gt;. This allows the entire background to be rendered in a single pass with the same active texture. The flagpole is additionally given a yellow specular color, which will give it a metallic sheen when we shade it. The flag is generated by evaluating the function &lt;tt&gt;calculate_flag_vertex&lt;/tt&gt; at regular intervals between zero and one on the &lt;i&gt;s&lt;/i&gt; and &lt;i&gt;t&lt;/i&gt; parametric axes, generating something that looks sort of like a flag flapping in the breeze. The flag being a separate mesh makes it easy to update the mesh data as the flag animates, and lets us render it with its own texture, loaded from &lt;tt&gt;flag.tga&lt;/tt&gt;.&lt;/p&gt;
&lt;h3&gt;Streaming dynamic mesh data&lt;/h3&gt;
&lt;pre&gt;void update_flag_mesh(
    struct flag_mesh const *mesh,
    struct flag_vertex *vertex_data,
    GLfloat time
) {
    GLsizei s, t, i;
    for (t = 0, i = 0; t &amp;lt; FLAG_Y_RES; ++t)
        for (s = 0; s &amp;lt; FLAG_X_RES; ++s, ++i) {
            GLfloat ss = FLAG_S_STEP * s, tt = FLAG_T_STEP * t;

            calculate_flag_vertex(&amp;vertex_data[i], ss, tt, time);
        }

    glBindBuffer(GL_ARRAY_BUFFER, mesh-&gt;vertex_buffer);
    glBufferData(
        GL_ARRAY_BUFFER,
        FLAG_VERTEX_COUNT * sizeof(struct flag_vertex),
        vertex_data,
        GL_STREAM_DRAW
    );
}&lt;/pre&gt;
&lt;p&gt;To animate the flag, we use our &lt;tt&gt;glutIdleFunc&lt;/tt&gt; callback to recalculate the flag&#39;s vertices and update the contents of the vertex buffer. We update the buffer with the same &lt;tt&gt;glBufferData&lt;/tt&gt; function we used to initialize it. However, both on initialization and on each update, we give the flag vertex data the &lt;tt&gt;GL_STREAM_DRAW&lt;/tt&gt; hint instead of the &lt;tt&gt;GL_STATIC_DRAW&lt;/tt&gt; hint we&#39;ve been using until now. This tells the OpenGL driver to optimize for the fact that we&#39;ll be continuously replacing the buffer with new data. Since only the positions and normals of the vertices themselves changes, the element buffer for the flag can remain static. The connectivity of the vertices doesn&#39;t change.&lt;/p&gt;
&lt;h3&gt;Using a depth buffer to order 3D objects&lt;/h3&gt;
&lt;p&gt;Since we&#39;re drawing multiple objects in &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; space, we need to ensure that objects closer to the viewer render on top of the objects behind them. An easy way to do this would be to just render the objects back-to-front&amp;mdash;in our case, render the background mesh first, then the flag on top of it&amp;mdash;but this is inefficient because of the &lt;b&gt;overdraw&lt;/b&gt; this approach leads to: fragments get generated and processed by the fragment shader for background objects, only to be immediately overwritten by the foreground objects in front of it. Back-to-front rendering also cannot render mutually overlapping objects, such as two interlocked rings, on its own, for rendering either object first will cause it to entirely overlap the other.&lt;/p&gt;
&lt;p&gt;Graphics cards use &lt;b&gt;depth buffers&lt;/b&gt; to provide efficient and reliable ordering of &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; objects. A depth buffer is a part of the framebuffer that sits alongside the color buffer, and like the color buffer, is a two-dimensional array of pixel values. Instead of color values, the depth buffer stores a depth value, associating a projection-space &lt;i&gt;z&lt;/i&gt; coordinate to each pixel. When a triangle is rasterized with &lt;b&gt;depth testing&lt;/b&gt; enabled, each fragment&#39;s projected &lt;i&gt;z&lt;/i&gt; value is compared to the &lt;i&gt;z&lt;/i&gt; value currently stored in the depth buffer. If the fragment would be further away from the viewer than the current depth buffer value, the fragment is discarded. Otherwise, the fragment gets rendered to the color and depth buffers, the new &lt;i&gt;z&lt;/i&gt; value replacing the old depth buffer value.&lt;/p&gt;
&lt;p&gt;In addition to providing correct ordering of objects, depth buffering also minimizes the cost of overdraw if you render objects front-to-back. Although the rasterizer will still generate fragments for parts of objects obscured by already-rendered objects, modern GPUs can discard these obscured fragments before they get run through the fragment shader, reducing the number of overall fragment shader invocations the processor needs to execute. Since our flag mesh appears in front of the background mesh, we thus render the flag before the background so that the obscured parts of the background don&#39;t need to be shaded.&lt;/p&gt;
&lt;p&gt;To use depth testing in our program, we need to ask for a depth buffer in our framebuffer and then enable depth testing in the OpenGL state. With GLUT, we can ask for a depth buffer for a window by passing the &lt;tt&gt;GLUT_DEPTH&lt;/tt&gt; flag to &lt;tt&gt;glutInitDisplayMode&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;
int main(int argc, char* argv[])
{
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
    /* ... */
}
&lt;/pre&gt;
&lt;p&gt;We enable and disable depth testing by calling &lt;tt&gt;glEnable&lt;/tt&gt; or &lt;tt&gt;glDisable&lt;/tt&gt; with &lt;tt&gt;GL_DEPTH_TEST&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;static void init_gl_state(void)
{
    /* ... */
    glEnable(GL_DEPTH_TEST);
    /* ... */
}&lt;/pre&gt;
&lt;p&gt;When we start rendering our scene, we need to clear the depth buffer along with the color buffer to ensure that stale depth values don&#39;t affect rendering. We can clear both buffers with a single &lt;tt&gt;glClear&lt;/tt&gt; call by passing it both &lt;tt&gt;GL_COLOR_BUFFER_BIT&lt;/tt&gt; and &lt;tt&gt;GL_DEPTH_BUFFER_BIT&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;static void render(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /* ... */
}&lt;/pre&gt;
&lt;h3&gt;Back-face culling&lt;/h3&gt;
&lt;p&gt;Another potential source of overdraw comes from within an object. If you look at the cylindrical flagpole from any direction, you&#39;re going to see at most half of its surface. The front-facing triangles appear in front of the back-facing triangles, but they rasterize into the same pixels on screen. Depending on the ordering of triangles in the mesh, the front-facing triangles will either overdraw the back-facing triangles or the fragments of the back-facing triangles will fail the depth test, requiring some extra work from the GPU in either case.&lt;/p&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-back-face-culling-01.png&quot;&gt;
&lt;p&gt;However, we can get the GPU to cheaply and quickly discard back-facing triangles even before they get rasterized or depth-tested. If we enable &lt;b&gt;back-face culling&lt;/b&gt;, the graphics card will classify every triangle as front- or back-facing after running the vertex shader and immediately prior to rasterization, completely discarding back-facing triangles. It does this by looking at the &lt;b&gt;winding&lt;/b&gt; of each triangle in projection space. By default, triangles winding counterclockwise are considered front-facing. This works because transforming a triangle to face the opposite direction from the viewer reverses its winding. By constructing our meshes so that all of the triangles wind counterclockwise when viewed from the front, we can use back-face culling to eliminate most of the work of rasterizing those triangles when they face away from the viewer. Only the vertex shader will need to run for their vertices.&lt;/p&gt;
&lt;p&gt;Back-face culling is enabled and disabled by passing &lt;tt&gt;GL_CULL_FACE&lt;/tt&gt; to &lt;tt&gt;glEnable&lt;/tt&gt;/&lt;tt&gt;glDisable&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;static void init_gl_state(void)
{
    /* ... */
    glEnable(GL_CULL_FACE);
    /* ... */
}&lt;/pre&gt;
&lt;h3&gt;Updating the projection matrix and viewport&lt;/h3&gt;
&lt;p&gt;If you go back a chapter and try resizing the &lt;tt&gt;hello-gl&lt;/tt&gt; window, you&#39;ll notice that the image stretches to fit the new size of the window, ruining the aspect ratio we worked so hard to preserve. In order to maintain an accurate aspect ratio, we have to recalculate our projection matrix when the window size changes, taking the new aspect ratio into account. We also have to inform OpenGL of the new viewport size by calling &lt;tt&gt;glViewport&lt;/tt&gt;. GLUT allows us to provide a callback that gets invoked when the window is resized using &lt;tt&gt;glutReshapeFunc&lt;/tt&gt;:
&lt;pre&gt;static void reshape(int w, int h)
{
    g_resources.window_size[0] = w;
    g_resources.window_size[1] = h;
    update_p_matrix(g_resources.p_matrix, w, h);
    glViewport(0, 0, w, h);
}&lt;/pre&gt;
&lt;pre&gt;int main(int argc, char* argv[])
{
    /* ... */
    glutReshapeFunc(&amp;reshape);
    /* ... */
}&lt;/pre&gt;
&lt;p&gt;The &lt;tt&gt;update_p_matrix&lt;/tt&gt; function implements the perspective matrix formula from last chapter and stores the new projection matrix in the &lt;tt&gt;g_resources.p_matrix&lt;/tt&gt; array, from which we&#39;ll feed our shaders&#39; &lt;tt&gt;p_matrix&lt;/tt&gt; uniform variable.&lt;/p&gt;
&lt;h3&gt;Handling mouse and keyboard input with GLUT&lt;/h3&gt;
&lt;p&gt;GLUT provides extremely primitive support for mouse and keyboard input. In &lt;tt&gt;flag&lt;/tt&gt;, I&#39;ve made it so that dragging the mouse moves the view around, and the view snaps back to its original position when the mouse button is released. GLUT offers a &lt;tt&gt;glutMotionFunc&lt;/tt&gt; callback that gets called when the mouse moves while a button is held down and a &lt;tt&gt;glutMouseFunc&lt;/tt&gt; that gets called when a mouse button is pressed or released. (There&#39;s also &lt;tt&gt;glutPassiveMotionFunc&lt;/tt&gt; to handle mouse motion when a button isn&#39;t pressed, which we don&#39;t use.) Our &lt;tt&gt;glutMotionFunc&lt;/tt&gt; adjusts the model-view matrix relative to the distance from the center of the window, and our &lt;tt&gt;glutMouseFunc&lt;/tt&gt; resets it when the mouse button is let go:&lt;/p&gt;
&lt;pre&gt;static void drag(int x, int y)
{
    float w = (float)g_resources.window_size[0];
    float h = (float)g_resources.window_size[1];
    g_resources.eye_offset[0] = (float)x/w - 0.5f;
    g_resources.eye_offset[1] = -(float)y/h + 0.5f;
    update_mv_matrix(g_resources.mv_matrix, g_resources.eye_offset);
}

static void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_UP) {
        g_resources.eye_offset[0] = 0.0f;
        g_resources.eye_offset[1] = 0.0f;
        update_mv_matrix(g_resources.mv_matrix, g_resources.eye_offset);
    }
}&lt;/pre&gt;
&lt;pre&gt;int main(int argc, char* argv[])
{
    /* ... */
    glutMotionFunc(&amp;drag);
    glutMouseFunc(&amp;mouse);
    /* ... */
}&lt;/pre&gt;
&lt;p&gt;The &lt;tt&gt;update_mv_matrix&lt;/tt&gt; function is similar to &lt;tt&gt;update_p_matrix&lt;/tt&gt;. It generates a translation matrix, following the formula from last chapter, and stores it to &lt;tt&gt;g_resources.mv_matrix&lt;/tt&gt;, from which we feed the shaders&#39; &lt;tt&gt;mv_matrix&lt;/tt&gt; uniform variable.&lt;/p&gt;
&lt;p&gt;I also rigged &lt;tt&gt;flag&lt;/tt&gt; so you can reload the GLSL program from disk while the demo is running by pressing the &lt;tt&gt;R&lt;/tt&gt; key. The &lt;tt&gt;glutKeyboardFunc&lt;/tt&gt; callback gets called when a key is pressed. Our callback checks if the pressed key was &lt;tt&gt;R&lt;/tt&gt;, and if so, calls &lt;tt&gt;update_flag_program&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;static void keyboard(unsigned char key, int x, int y)
{
    if (key == &#39;r&#39; || key == &#39;R&#39;) {
        update_flag_program();
    }
}&lt;/pre&gt;
&lt;pre&gt;int main(int argc, char* argv[])
{
    /* ... */
    glutKeyboardFunc(&amp;keyboard);
    /* ... */
}&lt;/pre&gt;
&lt;p&gt;&lt;tt&gt;update_flag_program&lt;/tt&gt; attempts to load, compile, and link the &lt;tt&gt;flag.v.glsl&lt;/tt&gt; and &lt;tt&gt;flag.f.glsl&lt;/tt&gt; files from disk, and if successful, replaces the old shader and program objects.&lt;/p&gt;

&lt;p&gt;That covers the C code for the &lt;tt&gt;flag&lt;/tt&gt; demo. The actual shading happens inside the GLSL code, which we&#39;ll look at next.&lt;/p&gt;
&lt;h3&gt;Phong shading&lt;/h3&gt;
&lt;p&gt;Physically accurate light simulation requires expensive algorithms that have only recently become possible for even high-end computer clusters to calculate in real time. Fortunately, human eyes don&#39;t require perfect physical accuracy, especially not for fast-moving animated graphics, and real-time computer graphics has come a long way rendering impressive graphics on typical consumer hardware using cheap tricks that approximate the behavior of light without simulating it perfectly. The most fundamental of these tricks is the &lt;b&gt;Phong shading model&lt;/b&gt;, an inexpensive approximation of how light interacts with simple materials developed by computer graphics pioneer Bui Tuong Phong in the early 1970s. Phong shading is a &lt;b&gt;local illumination&lt;/b&gt; simulation&amp;mdash;it only considers the direct interaction between a light source and a single point. Because of this, Phong shading alone cannot calculate effects that involve the influence of other objects in a scene, such as shadows and mirror reflections. This is why the flag casts no shadow on the ground or wall behind it.&lt;/p&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-phong-01.png&quot;&gt;
&lt;p&gt;
The Phong model involves three different lighting terms:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;ambient&lt;/b&gt; reflection, a constant term that simulates the background level of light;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;diffuse&lt;/b&gt; reflection, which gives the material what we usually think of as its color;&lt;/li&gt;
&lt;li&gt;and &lt;b&gt;specular&lt;/b&gt; reflection, the shine of polished or metallic surfaces.
&lt;/ul&gt;
&lt;h3&gt;Diffuse and ambient reflection&lt;/h3&gt;
&lt;p&gt;If you hold a flat sheet of paper up to a lamp in a dark room, it will appear brightest when it faces the lamp head-on, and appear dimmer as you rotate it away from the light, reaching its darkest when it&#39;s perpendicular to the light. Curved surfaces behave the same way; if you roll up or crumple the paper, its surface will be brightest where it faces the light the most directly. The wider the angle between the surface normal and the light direction, the darker the paper appears. If the paper and light remain stationary but you move your head, the paper&#39;s apparent color and brightness won&#39;t change. Likewise, in the &lt;tt&gt;flag&lt;/tt&gt; demo, if you drag the view with the mouse, you can see the flag&#39;s shading remains the same. The surface reflects light evenly in every direction, or &quot;diffusely.&quot; This basic lighting effect is thus called &lt;b&gt;diffuse reflection&lt;/b&gt;.&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-phong-diffuse-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
There&#39;s an inexpensive operation called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dot_product&quot;&gt;&lt;b&gt;dot product&lt;/b&gt;&lt;/a&gt; that produces a scalar value from two vectors related to the angle between them. Given two unit vectors &lt;i&gt;u&lt;/i&gt; and &lt;i&gt;v&lt;/i&gt;, if their dot product &lt;i&gt;u &amp;#xb7; v&lt;/i&gt; (pronounced &quot;u dot v&quot;) is one, then the vectors face the exact same direction; if zero, they&#39;re perpendicular; and if negative one, they face exact opposite directions. Positive dot products indicate acute angles while negative dot products indicate obtuse angles. GLSL provides a function &lt;tt&gt;dot(u,v)&lt;/tt&gt; to calculate the dot product of two same-sized &lt;tt&gt;vec&lt;/tt&gt; values.
&lt;p&gt;
The dot product&#39;s behavior follows that of diffuse reflection: surfaces reflect more light the more parallel to a light source they become, or in other words, the closer the dot product of their normal and the light&#39;s direction gets to one. Perpendicular or back-facing surfaces reflect no light, and their dot product will be zero or negative. This relationship between the dot product and diffuse brightness was first observed by 18th-century physicist Johann Lambert and is referred to as &lt;a href=&quot;http://en.wikipedia.org/wiki/Lambertian_reflectance&quot;&gt;&lt;b&gt;Lambertian reflectance&lt;/b&gt;&lt;/a&gt;, and surfaces that exhibit the behavior are called &lt;b&gt;Lambertian surfaces&lt;/b&gt;. Phong shading uses Lambertian reflectance to model diffuse reflection, taking the dot product of the surface normal and the direction from the surface to the light source. If the dot product is greater than zero, it is multiplied by the diffuse color of the light, and the result is multiplied with the surface diffuse color to get the shaded result. (Multiplying two color values involves multiplying their corresponding red, green, blue, and alpha components together, which is what GLSL&#39;s &lt;tt&gt;*&lt;/tt&gt; operator does when given two &lt;tt&gt;vec4&lt;/tt&gt;s.) If the dot product is zero or negative, the diffuse color will be zero.
&lt;/p&gt;
&lt;p&gt;
However, in the real world, even when a surface isn&#39;t directly lit, it still won&#39;t appear pitch black. In any enclosed area, there will be a certain amount of &lt;b&gt;ambient reflection&lt;/b&gt; bouncing around, dimly illuminating areas that the light sources don&#39;t directly hit. The Phong model simulates the ambient effect by assigning light sources a constant ambient color. This ambient color gets added to the light&#39;s diffuse color after it&#39;s been multiplied by the dot product. The sum of ambient and diffuse effect colors is then multiplied by the surface&#39;s diffuse color to give the shaded result.
&lt;/p&gt;

&lt;h3&gt;Specular reflection&lt;/h3&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-phong-specular-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;Not all surfaces reflect light uniformly; many materials, including metals, glass, hair, and skin, have a reflective sheen. Unlike with diffuse reflection, if the viewer moves while a light source and shiny object remain stationary, the shine will move along the surface with the viewer. You can see this simulated in the &lt;tt&gt;flag&lt;/tt&gt; demo by looking at the flagpole: as you drag the view up and down, the gold sheen moves along the pole with you. Physically, an object appears shiny when its surface is covered in highly reflective &lt;b&gt;microfacets&lt;/b&gt;. These facets face every direction, creating a bright shiny spot where the light source reflects directly toward the viewer. This effect is called &lt;b&gt;specular reflection&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;The specular effect is caused by reflection from the light source to the viewer, so Phong shading simulates the specular effect by reflecting the light direction around the surface normal to give a reflection direction. We can then take the dot product of the reflection direction and the direction from the surface to the viewer. Microfacets on a specular surface follow a &lt;b&gt;normal distribution&lt;/b&gt;: a plurality of facets lie parallel to the surface, and there is an exponential dropoff in the number of facets at steeper angles from the surface. The dropoff is sharper for more polished surfaces, giving a smaller, tighter specular highlight. Phong shading approximates this distribution by raising the dot product to an exponent called the &lt;b&gt;shininess factor&lt;/b&gt;, with higher shininess giving a more polished shine and lower factors giving a more diffuse sheen. This final specular factor is then multiplied by the specular colors of the light source and surface, and the result added to the diffuse and ambient colors to give the final color. Non-specular surfaces have a transparent specular color with red, green, blue, and alpha components set to zero, which eliminates the specular term from the shading equation.&lt;/p&gt;

&lt;h3&gt;Implementing Phong shading in GLSL&lt;/h3&gt;
&lt;p&gt;
Shading calculations are usually performed in the vertex and fragment shaders, where they can leverage the GPU&#39;s parallel processing power. (This is where the term &quot;shader&quot; for GPU programs comes from.) Let&#39;s bring back the graphics pipeline diagram to get an overview of the Phong shading dataflow:
&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-pipeline-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;For the best accuracy, we perform shading at a per-fragment level. (For better performance, shading can also be done in the vertex shader and the results interpolated between vertices, but this will lead to less accurate shading, especially for specular effects.) The vertex shader, &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/flag.v.glsl&quot;&gt;&lt;tt&gt;flag.v.glsl&lt;/tt&gt;&lt;/a&gt;, thus only performs transformation and projection, using the &lt;tt&gt;p_matrix&lt;/tt&gt; and &lt;tt&gt;mv_matrix&lt;/tt&gt; we pass in as uniforms. The shader forwards most of the material vertex attributes to varying variables for the fragment shader to use:
&lt;/p&gt;
&lt;pre&gt;#version 110

uniform mat4 p_matrix, mv_matrix;
uniform sampler2D texture;

attribute vec3 position, normal;
attribute vec2 texcoord;
attribute float shininess;
attribute vec4 specular;

varying vec3 frag_position, frag_normal;
varying vec2 frag_texcoord;
varying float frag_shininess;
varying vec4 frag_specular;

void main()
{
    vec4 eye_position = mv_matrix * vec4(position, 1.0);
    gl_Position = p_matrix * eye_position;
    frag_position = eye_position.xyz;
    frag_normal   = (mv_matrix * vec4(normal, 0.0)).xyz;
    frag_texcoord = texcoord;
    frag_shininess = shininess;
    frag_specular = specular;
}&lt;/pre&gt;
&lt;p&gt;In addition to the texture coordinate, shininess, and specular color, the vertex shader also outputs to the fragment shader the model-view-transformed vertex position. The model-view matrix transforms the coordinate space so that the viewer is at the origin, so we can determine the surface-to-viewer direction needed by the specular calculation from ths transformed position. We likewise transform the normal vector to keep it in the same frame of reference as the position. Since the normal is a directional vector without a position, we apply the matrix to it with a &lt;i&gt;w&lt;/i&gt; component of zero, which cancels out the translation of the modelview matrix and only applies its rotation. With this set of varying values, the fragment shader, &lt;a href=&quot;http://github.com/jckarter/ch4-flag/blob/master/flag.v.glsl&quot;&gt;&lt;tt&gt;flag.f.glsl&lt;/tt&gt;&lt;/a&gt;, can perform the actual Phong calculation:&lt;/p&gt;
&lt;pre&gt;#version 110

uniform mat4 p_matrix, mv_matrix;
uniform sampler2D texture;

varying vec3 frag_position, frag_normal;
varying vec2 frag_texcoord;
varying float frag_shininess;
varying vec4 frag_specular;

const vec3 light_direction = vec3(0.408248, -0.816497, 0.408248);
const vec4 light_diffuse = vec4(0.8, 0.8, 0.8, 0.0);
const vec4 light_ambient = vec4(0.2, 0.2, 0.2, 1.0);
const vec4 light_specular = vec4(1.0, 1.0, 1.0, 1.0);

void main()
{
    vec3 mv_light_direction = (mv_matrix * vec4(light_direction, 0.0)).xyz,
         normal = normalize(frag_normal),
         eye = normalize(frag_position),
         reflection = reflect(mv_light_direction, normal);

    vec4 frag_diffuse = texture2D(texture, frag_texcoord);
    vec4 diffuse_factor
        = max(-dot(normal, mv_light_direction), 0.0) * light_diffuse;
    vec4 ambient_diffuse_factor
        = diffuse_factor + light_ambient;
    vec4 specular_factor
        = max(pow(-dot(reflection, eye), frag_shininess), 0.0)
            * light_specular;
    
    gl_FragColor = specular_factor * frag_specular
        + ambient_diffuse_factor * frag_diffuse;
}&lt;/pre&gt;
&lt;p&gt;To keep things simple, the shader defines a single light source using &lt;tt&gt;const&lt;/tt&gt; values in the shader source. A real renderer would likely feed these light parameters in as uniform values, so that lights can be moved or their material attributes changed from the host program. With the light attributes embedded in the GLSL as constants, it&#39;s easy to change the light attributes in the source, press &lt;tt&gt;R&lt;/tt&gt; to reload the shader, and see the result. Our light source acts as if it were infinitely far away, shining from the same &lt;tt&gt;light_direction&lt;/tt&gt; on every surface in the scene. The light is white, with a 20% baseline ambient light level. It can be made colored by replacing &lt;tt&gt;light_diffuse&lt;/tt&gt;, &lt;tt&gt;light_ambient&lt;/tt&gt;, &lt;tt&gt;light_specular&lt;/tt&gt; with RGBA values.&lt;/p&gt;
&lt;p&gt;The fragment shader uses several new GLSL functions we haven&#39;t seen before:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;tt&gt;normalize(v)&lt;/tt&gt; returns a unit vector with the same direction as &lt;tt&gt;v&lt;/tt&gt;. We use it here to convert the fragment position into a direction vector, and to ensure that the normal is a unit vector. Even if our original vertex normals are all unit vectors, their linear interpolations won&#39;t be.&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;pow(x,n)&lt;/tt&gt; raises &lt;tt&gt;x&lt;/tt&gt; to the &lt;tt&gt;n&lt;/tt&gt;th power, which we use to apply the specular shininess factor.&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;max(n,m)&lt;/tt&gt; returns the larger of &lt;tt&gt;n&lt;/tt&gt; or &lt;tt&gt;m&lt;/tt&gt;. We use it to clamp dot products less than zero so they shade the same as if they were zero.&lt;/li&gt;
&lt;li&gt;&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-reflection-01.png&quot;&gt;&lt;tt&gt;reflect(u,v)&lt;/tt&gt; reflects the vector &lt;tt&gt;u&lt;/tt&gt; around &lt;tt&gt;v&lt;/tt&gt;, giving a vector that makes the same angle with &lt;tt&gt;v&lt;/tt&gt; as &lt;tt&gt;u&lt;/tt&gt;, but in the opposite direction. With it we derive the reflected eye direction for the specular calculation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We transform our constant &lt;tt&gt;light_direction&lt;/tt&gt; to put it in the same coordinate space as the &lt;tt&gt;normal&lt;/tt&gt; and &lt;tt&gt;eye&lt;/tt&gt; vectors. We then sample the surface&#39;s diffuse &lt;tt&gt;color&lt;/tt&gt; from the mesh texture We assign the shaded value to &lt;tt&gt;gl_FragColor&lt;/tt&gt; to generate the final shaded fragment.&lt;/p&gt;

&lt;h3&gt;Tweaking the Phong model for stylistic effects&lt;/h3&gt;
&lt;p&gt;Before we wrap things up, let&#39;s take a quick look at how the Phong framework can be manipulated to give more stylized results. The classic Phong model is a &lt;b&gt;photorealistic&lt;/b&gt; model: it attempts to model real-world light behavior. But photorealism isn&#39;t always desirable. Many games set themselves apart visually by using more stylized shading effects. These effects often use the basic Phong model of diffuse, ambient, and specular lighting, but they warp the individual factors before summing them together.&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl4-diffuse-effects-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;As a trivial example, we can get a brighter, softer shading effect if, instead of clamping the diffuse dot product of back-facing surfaces to zero, we scale it so that perpendicular surfaces receive half illumination, and back-facing surfaces scale linearly toward zero. &lt;i&gt;Team Fortress 2&lt;/i&gt; uses this &quot;half Lambert&quot; reflectance scale, so called because the standard Lambertian dropoff rate is halved, as a basis for its cartoonish but semi-photorealistic look (albeit &lt;a href=&quot;http://www.valvesoftware.com/publications/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf&quot;&gt;heavily modified&lt;/a&gt;). Let&#39;s modify &lt;tt&gt;flag.f.glsl&lt;/tt&gt; to warp the diffuse dot product:
&lt;/p&gt;
&lt;pre&gt;float warp_diffuse(float d)
{
    return d * 0.5 + 0.5;
}

void main()
{
    // ...
    vec4 diffuse_factor
        = max(&lt;span class=&quot;highlight&quot;&gt;warp_diffuse(&lt;/span&gt;-dot(normal, mv_light_direction)&lt;span class=&quot;highlight&quot;&gt;)&lt;/span&gt;, 0.0) * light_diffuse;
    // ...
}

&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl4-flag-half-lambert-shaded.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
A popular effect that builds from this half-Lambert scale is &lt;b&gt;cel shading&lt;/b&gt;, in which a stair-step function is applied to the half-Lambert factor so that surfaces are shaded flatly with higher contrast between light and dark areas, in the style of traditional hand-drawn animation cels. &lt;i&gt;Jet Set Radio&lt;/i&gt; pioneered this look, and it&#39;s since been used in countless games. Implementing it in GLSL is easy:
&lt;/p&gt;
&lt;pre&gt;float cel(float d)
{
    return smoothstep(0.35, 0.37, d) * 0.4 + smoothstep(0.70, 0.72, d) * 0.6;
}

float warp_diffuse(float d)
{
    return cel(d * 0.5 + 0.5);
}&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl4-flag-cel-shaded.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;GLSL&#39;s &lt;tt&gt;smoothstep(lo,hi,x)&lt;/tt&gt; function behaves like this: if &lt;tt&gt;x&lt;/tt&gt; is less than &lt;tt&gt;lo&lt;/tt&gt;, it returns &lt;tt&gt;0.0&lt;/tt&gt;; if greater than &lt;tt&gt;hi&lt;/tt&gt;, it returns &lt;tt&gt;1.0&lt;/tt&gt;; if in between, it transitions linearly from zero to one. Our &lt;tt&gt;cel&lt;/tt&gt; function above uses &lt;tt&gt;smoothstep&lt;/tt&gt; to create three flat shading levels with short linear transitions in between.&lt;/p&gt;
&lt;p&gt;
There are other effects that can be performed by messing with the &lt;tt&gt;warp_diffuse&lt;/tt&gt; function. For example, the function doesn&#39;t need to be &lt;tt&gt;float&lt;/tt&gt;-to-&lt;tt&gt;float&lt;/tt&gt; but could also map to a color scale; you could map greater dot products to warmer reddish colors while lesser products map to cooler bluish colors to give an artistic illustration effect. I encourage you to experiment with the fragment shader code to see what other effects you can create.
&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;With Phong shading implemented, we can start adding additional effects to further improve the look of the flag scene. The most glaring problem is the lack of shadow cast by the flag, so next chapter we&#39;ll look at shadow mapping, a technique for rendering accurate shadows into a scene, and learn about off-screen framebuffer objects in the process. Meanwhile, if you&#39;re interested in learning more about real-time shading techniques on your own without an OpenGL bias, I highly recommend the book &lt;a href=&quot;http://www.realtimerendering.com/&quot;&gt;&lt;i&gt;Real-Time Rendering&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html&quot;&gt;&amp;laquo; Chapter 3&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/h4&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-07-15T15:06:09+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 3: 3D transformation and projection</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html&quot;&gt;&amp;laquo; Chapter 2.3&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html&quot;&gt;Chapter 4 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;
The GPU&#39;s specialty, and by extension OpenGL&#39;s, is in rendering three-dimensional scenes. If you compare &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;last chapter&lt;/a&gt;&#39;s &lt;tt&gt;hello-gl&lt;/tt&gt; program to, say, Crysis, you might notice that our demo is missing one of those dimensions (among other things). In this chapter, I&#39;m going to fix that. We&#39;ll cover the basic math that makes &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; rendering happen, looking at how &lt;b&gt;transformations&lt;/b&gt; are done using &lt;b&gt;matrices&lt;/b&gt; and how &lt;b&gt;perspective projection&lt;/b&gt; works. Wikipedia does a great job going in-depth about the algorithmic details, so I&#39;m going to spend most of my time talking at a high level about what math we use and why, linking to the relevant Wikipedia articles if you&#39;re interested in exploring further. As we look at different transformations, we&#39;re going to take the vertex shader from last chapter and extend it to implement those transformations, animating the &quot;hello world&quot; image by moving its rectangle around in &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; space.
&lt;/p&gt;
&lt;p&gt;Before we start, there are some changes we need to make to last chapter&#39;s &lt;tt&gt;hello-gl&lt;/tt&gt; program so that it&#39;s easier to play around with. These changes will allow us to write different vertex shaders and supply them as command-line arguments when we run the program, like so:&lt;/p&gt;
&lt;pre&gt;
./hello-gl hello-gl.v.glsl
&lt;/pre&gt;
&lt;p&gt;You can pull these changes from my &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3&quot;&gt;&lt;tt&gt;hello-gl-ch3&lt;/tt&gt; github repo&lt;/a&gt;.
&lt;/p&gt;
&lt;h3&gt;Updating &lt;tt&gt;hello-gl&lt;/tt&gt;&lt;/h3&gt;
&lt;p&gt;We&#39;ll start by expanding our vertex array to hold three-dimensional vectors. We&#39;ll actually pad them out to four components&amp;mdash;the fourth component&#39;s purpose will become clear soon. For now, we&#39;ll just set all the fourth components to one. Let&#39;s update our vertex array data in &lt;tt&gt;hello-gl.c&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;
static const GLfloat g_vertex_buffer_data[] = { 
    &lt;span class=&quot;highlight&quot;&gt;-1.0f, -1.0f, 0.0f, 1.0f,
     1.0f, -1.0f, 0.0f, 1.0f,
    -1.0f,  1.0f, 0.0f, 1.0f,
     1.0f,  1.0f, 0.0f, 1.0f&lt;/span&gt;
};
&lt;/pre&gt;
&lt;p&gt;and our &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt; call:&lt;/p&gt;
&lt;pre&gt;
    glVertexAttribPointer(
        g_resources.attributes.position,  /* attribute */
        &lt;span class=&quot;highlight&quot;&gt;4&lt;/span&gt;,                                /* size */
        GL_FLOAT,                         /* type */
        GL_FALSE,                         /* normalized? */
        &lt;span class=&quot;highlight&quot;&gt;sizeof(GLfloat)*4&lt;/span&gt;,                /* stride */
        (void*)0                          /* array buffer offset */
    );
&lt;/pre&gt;
&lt;p&gt;When we start transforming our rectangle, it will no longer completely cover the window, so let&#39;s add a &lt;tt&gt;glClear&lt;/tt&gt; to our &lt;tt&gt;render&lt;/tt&gt; function so we don&#39;t get garbage in the background. We&#39;ll set it to dark grey so it&#39;s distinct from the black background of our images:
&lt;pre&gt;
static void render(void)
{
    &lt;span class=&quot;highlight&quot;&gt;glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);&lt;/span&gt;
    /* ... */
}
&lt;/pre&gt;
&lt;p&gt;Now let&#39;s generalize a few things. First, we&#39;ll change our uniform state to include GLUT&#39;s &lt;tt&gt;timer&lt;/tt&gt; value directly rather than the &lt;tt&gt;fade_factor&lt;/tt&gt; precalculated. This will let our new vertex shaders perform additional time-based effects.&lt;/p&gt;
&lt;pre&gt;
static void update_&lt;span class=&quot;highlight&quot;&gt;timer&lt;/span&gt;(void)
{
    int milliseconds = glutGet(GLUT_ELAPSED_TIME);
    g_resources.&lt;span class=&quot;highlight&quot;&gt;timer&lt;/span&gt; = &lt;span class=&quot;highlight&quot;&gt;(float)milliseconds * 0.001f&lt;/span&gt;;
    glutPostRedisplay();
}
&lt;/pre&gt;
&lt;p&gt;You&#39;ll also have to search-and-replace all of the other references to &lt;tt&gt;fade_factor&lt;/tt&gt; with &lt;tt&gt;timer&lt;/tt&gt;. Once that&#39;s done, we&#39;ll change our &lt;tt&gt;main&lt;/tt&gt; and &lt;tt&gt;make_resources&lt;/tt&gt; functions so they can take the vertex shader filename as an argument. This way, we can easily switch between the different vertex shaders we&#39;ll be writing:&lt;/p&gt;
&lt;pre&gt;
static int make_resources(&lt;span class=&quot;highlight&quot;&gt;const char *vertex_shader_file&lt;/span&gt;)
{
    /* ... */
    g_resources.vertex_shader = make_shader(
        GL_VERTEX_SHADER,
        &lt;span class=&quot;highlight&quot;&gt;vertex_shader_file&lt;/span&gt;
    );
    /* ... */
}
&lt;/pre&gt;
&lt;pre&gt;
int main(int argc, char** argv)
{
    /* ... */
    if (!make_resources(&lt;span class=&quot;highlight&quot;&gt;argc &gt;= 2 ? argv[1] : &quot;hello-gl.v.glsl&quot;&lt;/span&gt;)) {
        fprintf(stderr, &quot;Failed to load resources\n&quot;);
        return 1;
    }
    /* ... */
}
&lt;/pre&gt;
&lt;p&gt;Now let&#39;s update our shaders to match our changes to the uniform state and vertex array. We can move the fade factor calculation into the vertex shader, which will pass it on to the fragment shader as a &lt;tt&gt;varying&lt;/tt&gt; value. In &lt;tt&gt;hello-gl.v.glsl&lt;/tt&gt;:&lt;/p&gt;
&lt;pre&gt;
#version 110

&lt;span class=&quot;highlight&quot;&gt;uniform float timer;&lt;/span&gt;

attribute &lt;span class=&quot;highlight&quot;&gt;vec4&lt;/span&gt; position;

varying vec2 texcoord;
&lt;span class=&quot;highlight&quot;&gt;varying float fade_factor;&lt;/span&gt;

void main()
{
    gl_Position = &lt;span class=&quot;highlight&quot;&gt;position&lt;/span&gt;;
    texcoord = position&lt;span class=&quot;highlight&quot;&gt;.xy&lt;/span&gt; * vec2(0.5) + vec2(0.5);
    &lt;span class=&quot;highlight&quot;&gt;fade_factor = sin(timer) * 0.5 + 0.5;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;A new feature of GLSL I use here is vector &lt;b&gt;swizzling&lt;/b&gt;: not only can you address the components of a &lt;tt&gt;vec&lt;/tt&gt; type as if they were struct fields by using &lt;tt&gt;.x&lt;/tt&gt;, &lt;tt&gt;.y&lt;/tt&gt;, &lt;tt&gt;.z&lt;/tt&gt;, and &lt;tt&gt;.w&lt;/tt&gt; for the first through fourth components, you can also string together the element letters to collect multiple components in any order into a longer or shorter vector type. &lt;tt&gt;position.xy&lt;/tt&gt; picks out as a &lt;tt&gt;vec2&lt;/tt&gt; the first two elements of our now four-component &lt;tt&gt;position&lt;/tt&gt; vector. We can then feed that &lt;tt&gt;vec2&lt;/tt&gt; into the calculation for our &lt;tt&gt;texcoord&lt;/tt&gt;, which remains two components long.
&lt;/p&gt;
&lt;p&gt;Finally, in &lt;tt&gt;hello-gl.f.glsl&lt;/tt&gt;, we make &lt;tt&gt;fade_factor&lt;/tt&gt; assume its new &lt;tt&gt;varying&lt;/tt&gt; identity:&lt;/p&gt;
&lt;pre&gt;
#version 110

uniform sampler2D textures[2];

&lt;span class=&quot;highlight&quot;&gt;varying&lt;/span&gt; float fade_factor;
varying vec2 texcoord;

void main()
{
    gl_FragColor = mix(
        texture2D(textures[0], texcoord),
        texture2D(textures[1], texcoord),
        fade_factor
    );
}
&lt;/pre&gt;
&lt;p&gt;&lt;a name=&quot;gl3-math-part&quot;&gt;With those changes out of the way, we can recompile the executable once and not have to mess with C any more for the rest of the chapter. We can write new vertex shader files and execute them using &lt;tt&gt;./hello-gl vertex-shader.v.glsl&lt;/tt&gt; without recompiling anything. Now we&#39;re ready do some math!&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Projection and world space&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-projection-space-01.png&quot;&gt;
&lt;p&gt;The destination space for the vertex shader, which I&#39;ve been informally referring to as &quot;screen space&quot; in the last couple of chapters, is more precisely called &lt;b&gt;projection space&lt;/b&gt;. The visible part of projection space is the unit-radius cube from (&amp;ndash;1, &amp;ndash;1, &amp;ndash;1) to (1, 1, 1). Anything outside of this cube gets &lt;b&gt;clipped&lt;/b&gt; and thrown out. The &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt; axes map across the &lt;b&gt;viewport&lt;/b&gt;, the part of the screen in which any rendered output will be displayed, with (&amp;ndash;1, &amp;ndash;1, &lt;i&gt;z&lt;/i&gt;) corresponding to the lower left corner, (1, 1, &lt;i&gt;z&lt;/i&gt;) to the upper right, and (0, 0, &lt;i&gt;z&lt;/i&gt;) to the center. The rasterizer uses the &lt;i&gt;z&lt;/i&gt; coordinate to assign a depth value to every fragment it generates; if the framebuffer has a depth buffer, these depth values can be compared against the depth values of previously rendered fragments, allowing parts of newly-rendered objects to be hidden behind objects that have already been rendered into the framebuffer. (&lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, &amp;ndash;1) is the &lt;b&gt;near plane&lt;/b&gt; and maps to the nearest depth value. At the other end, (&lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, 1) is the &lt;b&gt;far plane&lt;/b&gt; and maps to the farthest depth value. Fragments with &lt;i&gt;z&lt;/i&gt; coordinates outside of that range get clipped against these planes just like they do the edges of the screen.&lt;/p&gt;
&lt;p&gt;Projection space is computationally convenient for the GPU, but it&#39;s not very usable by itself for modeling vertices within a scene. Rather than input projection-space vertices directly to the pipeline, most programs use the vertex shader to &lt;b&gt;project&lt;/b&gt; objects into it. The pre-projection coordinate system used by the program is called &lt;b&gt;world space&lt;/b&gt;, and can be moved, scaled, and rotated relative to projection space in whatever way the program needs. Within world space, objects also need to move around, changing position, orientation, size, and shape. Both of these operations, mapping world space to projection space and positioning objects in world space, are accomplished by performing &lt;b&gt;transformations&lt;/b&gt; with mathematical structures called &lt;b&gt;matrices&lt;/b&gt;.&lt;/p&gt;
&lt;h3&gt;Linear transformations with matrices&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Linear_transformation&quot;&gt;&lt;b&gt;Linear transformations&lt;/b&gt;&lt;/a&gt; are operations on an object that preserve the relative size and orientation of parts within the object while uniformly changing its overall size or orientation. They include &lt;b&gt;rotation&lt;/b&gt;, &lt;b&gt;scaling&lt;/b&gt;, and &lt;b&gt;shearing&lt;/b&gt;. If you&#39;ve ever used the &quot;free transform&quot; tool in Photoshop or GIMP, these are the sorts of transformations it performs. You can think of a linear transformation as taking the &lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, and &lt;i&gt;z&lt;/i&gt; axes of your coordinate space and mapping them to a new set of arbitrary axes &lt;i&gt;x&#39;&lt;/i&gt;, &lt;i&gt;y&#39;&lt;/i&gt;, and &lt;i&gt;z&#39;&lt;/i&gt;:
&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-linear-transformation-matrices-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
For clarity, the figure is two-dimensional, but the same idea applies to &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt;. To represent a linear transformation numerically, we can take the vector values of those new axes and arrange them into a 3&amp;#xd7;3 &lt;b&gt;matrix&lt;/b&gt;. We can then perform an operation called &lt;a href=&quot;http://en.wikipedia.org/wiki/Matrix_multiplication&quot;&gt;&lt;b&gt;matrix multiplication&lt;/b&gt;&lt;/a&gt; to apply a linear transformation to a vector, or to combine two transformations into a single matrix that represents the combined transformation. In standard mathematical notation, matrices are represented so that the axes are represented as columns going left-to-right. In GLSL and in the OpenGL API, matrices are represented as an array of vectors, each vector representing a column in the matrix. In source code, this results in the values looking transposed from their mathematical notation. This is called &lt;b&gt;column-major order&lt;/b&gt; (as opposed to row-major order, in which each vector element of the matrix array would be a row of the matrix). GLSL provides 2&amp;#xd7;2, 3&amp;#xd7;3, and 4&amp;#xd7;4 matrix types named &lt;tt&gt;mat2&lt;/tt&gt; through &lt;tt&gt;mat4&lt;/tt&gt;. It also overloads its multiplication operator for use between &lt;tt&gt;mat&lt;i&gt;n&lt;/i&gt;&lt;/tt&gt; values of the same type, and between &lt;tt&gt;mat&lt;i&gt;n&lt;/i&gt;&lt;/tt&gt;s and &lt;tt&gt;vec&lt;i&gt;n&lt;/i&gt;&lt;/tt&gt;s, to perform matrix-matrix and matrix-vector multiplication.
&lt;/p&gt;
&lt;p&gt;A nice property of linear transformations is that they work well with the rasterizer&#39;s linear interpolation. If we transform all of the vertices of a triangle using the same linear transformation, every point on its surface will retain its relative position to the vertices, so textures and other varying values will transform with the vertices they fill out.
&lt;p&gt;
Note that all linear transformations occur relative to the &lt;b&gt;origin&lt;/b&gt;, that is, the (0, 0, 0) point of the coordinate system, which remains constant through a linear transformation. Because of this, moving an object around in space, called &lt;b&gt;translation&lt;/b&gt; in mathematical terms, is &lt;i&gt;not&lt;/i&gt; a linear transformation, and cannot be represented with a 3&amp;#xd7;3 matrix or composed into other 3&amp;#xd7;3 linear transform matrices. We&#39;ll see how to integrate translation into transformation matrices shortly. For now, let&#39;s try some linear transformations:
&lt;/p&gt;
&lt;h3&gt;Rotation&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-rotation-matrix-01.png&quot;&gt;
&lt;p&gt;
We&#39;ll start by writing a shader that spins our rectangle around the &lt;i&gt;z&lt;/i&gt; axis. Using the &lt;tt&gt;timer&lt;/tt&gt; uniform value as a rotation angle, we&#39;ll construct a &lt;a href=&quot;http://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;, using the &lt;tt&gt;sin&lt;/tt&gt; and &lt;tt&gt;cos&lt;/tt&gt; functions to rotate our matrix axes around the unit circle. The shader looks like this; it&#39;s in the repo as &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/rotation.v.glsl&quot;&gt;&lt;tt&gt;rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:
&lt;/p&gt;
&lt;pre&gt;
#version 110

uniform float timer;

attribute vec4 position;

varying vec2 texcoord;
varying float fade_factor;

void main()
{
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    gl_Position = vec4(rotation * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
}
&lt;/pre&gt;
&lt;p&gt;(I&#39;m going to be listing only the &lt;tt&gt;main&lt;/tt&gt; function of the next few shaders; the &lt;tt&gt;uniform&lt;/tt&gt;, &lt;tt&gt;attribute&lt;/tt&gt;, and &lt;tt&gt;varying&lt;/tt&gt; declarations will all remain the same from here.) With our changes to &lt;tt&gt;hello-gl&lt;/tt&gt; we can run it like so:&lt;/p&gt;
&lt;pre&gt;
./hello-gl rotation.v.glsl
&lt;/pre&gt;
&lt;p&gt;And this is the result:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-rotation-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
&lt;h3&gt;Scaling to fit the aspect ratio&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-scaling-matrix-01.png&quot;&gt;
&lt;p&gt;
You probably noticed that the rectangle appears to be horizontally distorted as it rotates. This is because our window is wider than it is tall, so the screen distance covered along a unit on the &lt;i&gt;x&lt;/i&gt; axis of projection space is longer than the distance the same unit would cover along the &lt;i&gt;y&lt;/i&gt; axis. The window is 400 pixels wide and 300 pixels high, giving it an &lt;b&gt;aspect ratio&lt;/b&gt; of 4:3 (the width divided by the height). (This will change if we resize the window, but we won&#39;t worry about that for now.) We can compensate for this by applying a &lt;a href=&quot;http://en.wikipedia.org/wiki/Scaling_(geometry)#Matrix_representation&quot;&gt;scaling matrix&lt;/a&gt; that scales the &lt;i&gt;x&lt;/i&gt; axis by the reciprocal of the aspect ratio, as in &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/window-scaled-rotation.v.glsl&quot;&gt;&lt;tt&gt;window-scaled-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:
&lt;/p&gt;
&lt;pre&gt;
    mat3 window_scale = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    gl_Position = vec4(window_scale * rotation * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-matrix-order-01.png&quot;&gt;Note that the order in which we rotate and scale is important. Unlike scalar multiplication, matrix multiplication is &lt;i&gt;noncommutative&lt;/i&gt;: Changing the order of the arguments gives different results. This should make intuitive sense: &quot;rotate an object, then squish it horizontally&quot; gives a different result from &quot;squish an object horizontally, then rotate it&quot;. As matrix math, you write transformation sequences out right-to-left, backwards compared to English: &lt;tt&gt;scale * rotate * vector&lt;/tt&gt; rotates the vector first, whereas &lt;tt&gt;rotate * scale * vector&lt;/tt&gt; scales first.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-window-scale-rotation-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;Now that we&#39;ve compensated for the distortion of our window&#39;s projection space, we&#39;ve revealed a dirty secret. Our input rectangle is really a square, and it doesn&#39;t match the aspect ratio of our image, leaving it scrunched. We need to scale it again outward, this time &lt;i&gt;before&lt;/i&gt; we rotate, as in &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/window-object-scaled-rotation.v.glsl&quot;&gt;&lt;tt&gt;window-object-scaled-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:
&lt;pre&gt;
    mat3 window_scale = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    mat3 object_scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    gl_Position = vec4(window_scale * rotation * object_scale * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
&lt;/pre&gt;
&lt;p&gt;(Alternately, we could change our vertex array and apply a scaling transformation to our generated &lt;tt&gt;texcoord&lt;/tt&gt;s. But I promised we wouldn&#39;t be changing the C anymore in this chapter.)&lt;/p&gt; With this shader, our rectangle now rotates the way we would expect it to:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-window-object-scale-rotation-screenshot.png&quot;&gt;&lt;/center&gt;

&lt;h3&gt;Projection and model-view matrices&lt;/h3&gt;
&lt;p&gt;The &lt;tt&gt;window_scale&lt;/tt&gt; matrix conceptually serves a different purpose from the &lt;tt&gt;rotation&lt;/tt&gt; and &lt;tt&gt;object_scale&lt;/tt&gt; matrices. While the latter two matrices set up our input vertices to be where we want them in world space, the &lt;tt&gt;window_scale&lt;/tt&gt; serves to project world space into projection space in a way that gives an undistorted final render. Matrices used to orient objects in world space, like our &lt;tt&gt;rotation&lt;/tt&gt; and &lt;tt&gt;object_scale&lt;/tt&gt; matrices, are called &lt;b&gt;model-view matrices&lt;/b&gt;, because they are used both to transform models and to position them relative to the viewport. The matrix we use to project, in this case &lt;tt&gt;window_scale&lt;/tt&gt;, is called the &lt;b&gt;projection matrix&lt;/b&gt;. Although both kinds of matrix behave the same, and the line drawn between them is mathematically arbitrary, the distinction is useful because a &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; application will generally only need a few projection matrices that change rarely (usually only if the window size or screen resolution changes). On the other hand, there can be countless model-view matrices for all of the objects in a scene, which will update constantly as the objects animate.

&lt;h3&gt;Orthographic and perspective projection&lt;/h3&gt;
&lt;p&gt;Projecting with a scaling matrix, as we&#39;re doing here, produces an &lt;a href=&quot;http://en.wikipedia.org/wiki/Orthographic_projection&quot;&gt;orthographic projection&lt;/a&gt;, in which objects in &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; space are rendered at a constant scale regardless of their distance from the viewport. Orthographic projections are useful for rendering two-dimensional display elements, such as the UI controls of a game or graphics tool, and in modeling applications where the artist needs to see the exact scales of different parts of a model, but they don&#39;t adequately present &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; scenes in a way most viewers expect. To demonstrate this, let&#39;s break out of the &lt;span class=&quot;smallcap&quot;&gt;2d&lt;/span&gt; plane and alter our shader to rotate the rectangle around the &lt;i&gt;x&lt;/i&gt; axis, as in &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/orthographic-rotation.v.glsl&quot;&gt;&lt;tt&gt;orthographic-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
    const mat3 projection = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );

    mat3 rotation = mat3(
        vec3(1.0,         0.0,         0.0),
        vec3(0.0,  cos(timer),  sin(timer)),
        vec3(0.0, -sin(timer),  cos(timer))
    );
    mat3 scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    gl_Position = vec4(projection * rotation * scale * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-orthographic-rotation-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;With an orthographic projection, the rectangle doesn&#39;t very convincingly rotate in &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; space&amp;mdash;it just sort of accordions up and down. This is because the top and bottom edges of the rectangle remain the same apparent size as they move toward and away from the view. In the real world, objects appear smaller in our field of view proportional to how far from our eyes they are. This effect is called &lt;b&gt;perspective&lt;/b&gt;, and transforming objects to take perspective into account is called &lt;a href=&quot;http://en.wikipedia.org/wiki/3D_projection#Perspective_projection&quot;&gt;&lt;b&gt;perspective projection&lt;/b&gt;.&lt;/a&gt; Perspective projection is accomplished by shrinking objects proportionally to their distance from the &quot;eye&quot;. An easy way to do this is to divide each point&#39;s position by some function of its &lt;i&gt;z&lt;/i&gt; coordinate. Let&#39;s arbitrarily decide that zero on the &lt;i&gt;z&lt;/i&gt; axis remains unscaled, and that points elsewhere on the &lt;i&gt;z&lt;/i&gt; axis scale by half their distance from zero. Correspondingly, let&#39;s also scale the &lt;i&gt;z&lt;/i&gt; axis by half, so that the end of the rectangle coming toward us doesn&#39;t get clipped to the near plane as it gets magnified. We&#39;ll end up with the shader code in &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/naive-perspective-rotation.v.glsl&quot;&gt;&lt;tt&gt;naive-perspective-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:
&lt;pre&gt;
    const mat3 projection = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 0.5)
    );

    mat3 rotation = mat3(
        vec3(1.0,         0.0,         0.0),
        vec3(0.0,  cos(timer),  sin(timer)),
        vec3(0.0, -sin(timer),  cos(timer))
    );
    mat3 scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );

    vec3 projected_position = projection * rotation * scale * position.xyz;
    float perspective_factor = projected_position.z * 0.5 + 1.0;

    gl_Position = vec4(projected_position/perspective_factor, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-naive-perspective-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;Now the overall shape of the rectangle appears to rotate in perspective, but the texture mapping is all kinky. This is because perspective projection is a &lt;i&gt;nonlinear&lt;/i&gt; transformation&amp;mdash;different parts of the rectangle get scaled differently depending on how far away they are. This interferes with the linear interpolation the rasterizer applies to the texture coordinates across the surface of our triangles. To properly project texture coordinates as well as other varying values in perspective, we need a different approach that takes the rasterizer into account.&lt;/p&gt;

&lt;h3&gt;Homogeneous coordinates&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-homogeneous-coordinates-01.png&quot;&gt;
&lt;p&gt;Directly applying perspective to an object may not be a linear transformation, but the divisor that perspective applies is a linear function of the perspective distance. If we stored the divisor out-of-band as an extra component of our vectors, we could apply perspective as a matrix transformation, and the rasterizer could linearly interpolate texture coordinates correctly before the perspective divisor is applied. This is in fact what that mysterious 1.0 we&#39;ve been sticking in the fourth component of our vectors is for. The projection space that &lt;tt&gt;gl_Position&lt;/tt&gt; addresses uses &lt;a href=&quot;http://en.wikipedia.org/wiki/Homogeneous_coordinates&quot;&gt;&lt;b&gt;homogeneous coordinates&lt;/b&gt;&lt;/a&gt;. That fourth component, labeled &lt;i&gt;w&lt;/i&gt;, divides the &lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, and &lt;i&gt;z&lt;/i&gt; components when the coordinate is projected. In other words, the homogeneous coordinate [&lt;i&gt;x&lt;/i&gt;:&lt;i&gt;y&lt;/i&gt;:&lt;i&gt;z&lt;/i&gt;:&lt;i&gt;w&lt;/i&gt;] projects to the linear coordinate (&lt;i&gt;x&lt;/i&gt;/&lt;i&gt;w&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;/&lt;i&gt;w&lt;/i&gt;, &lt;i&gt;z&lt;/i&gt;/&lt;i&gt;w&lt;/i&gt;). 
&lt;/p&gt;
&lt;p&gt;
With this trick, we can construct a &lt;b&gt;perspective matrix&lt;/b&gt; that maps distances on the &lt;i&gt;z&lt;/i&gt; axis to scales on the &lt;i&gt;w&lt;/i&gt; axis. As I mentioned, the rasterizer also interpolates varying values in homogeneous space, before the coordinates are projected, so texture coordinates and other varying values will blend correctly over perspective-projected triangles using this matrix. The 3&amp;#xd7;3 linear transformation matrices we&#39;ve covered extend to 4&amp;#xd7;4 easily&amp;mdash;just extend the columns to four components and add a fourth column that leaves the &lt;i&gt;w&lt;/i&gt; axis unchanged. Let&#39;s update our vertex shader to use a proper perspective matrix and &lt;tt&gt;mat4&lt;/tt&gt;s to transform our rectangle, as in &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/perspective-rotation.v.glsl&quot;&gt;&lt;tt&gt;perspective-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:
&lt;/p&gt;
&lt;pre&gt;
    const mat4 projection = mat4(
        vec4(3.0/4.0, 0.0, 0.0, 0.0),
        vec4(    0.0, 1.0, 0.0, 0.0),
        vec4(    0.0, 0.0, 0.5, 0.5),
        vec4(    0.0, 0.0, 0.0, 1.0)
    );

    mat4 rotation = mat4(
        vec4(1.0,         0.0,         0.0, 0.0),
        vec4(0.0,  cos(timer),  sin(timer), 0.0),
        vec4(0.0, -sin(timer),  cos(timer), 0.0),
        vec4(0.0,         0.0,         0.0, 1.0)
    );
    mat4 scale = mat4(
        vec4(4.0/3.0, 0.0, 0.0, 0.0),
        vec4(    0.0, 1.0, 0.0, 0.0),
        vec4(    0.0, 0.0, 1.0, 0.0),
        vec4(    0.0, 0.0, 0.0, 1.0)
    );

    gl_Position = projection * rotation * scale * position;
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-perspective-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;The texture coordinates now project correctly with the rectangle as it rotates in perspective.&lt;/p&gt;

&lt;h3&gt;Affine transformations&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-translation-matrix-01.png&quot;&gt;
&lt;p&gt;
Homogeneous coordinates let us pull another trick using 4&amp;#xd7;4 matrices. Earlier, I noted that translation cannot be represented in a 3&amp;#xd7;3 linear transformation matrix. While translation can be achieved by simple vector addition, combinations of translations and linear transformations can&#39;t be easily composed that way. However, by using the &lt;i&gt;w&lt;/i&gt; axis column of a 4&amp;#xd7;4 matrix to map the &lt;i&gt;w&lt;/i&gt; axis value back onto the &lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, and &lt;i&gt;z&lt;/i&gt; axes, we can set up a &lt;b&gt;translation matrix&lt;/b&gt;. The combination of a linear transformation with a translation is referred to as an &lt;b&gt;affine transformation&lt;/b&gt;. Like our 3&amp;#xd7;3 linear transformation matrices, 4&amp;#xd7;4 affine transformation matrices can be multiplied together to give new matrices combining their transformations.
&lt;/p&gt;

&lt;h3&gt;Constructing a view frustum matrix&lt;/h3&gt;
&lt;p&gt;The perspective projection matrix we constructed above gets the job done, but it&#39;s a bit ad-hoc. An easier to understand way of projecting world space would be to consider the origin to be the camera position and project from there. Now that we know how to make translation matrices, we can leave the model-view matrix to position the camera in world space. Different programs will also want to control the &lt;a href=&quot;http://en.wikipedia.org/wiki/Angle_of_view&quot;&gt;&lt;b&gt;angle of view&lt;/b&gt;&lt;/a&gt; (&lt;i&gt;&amp;alpha;&lt;/i&gt;) of the projection, and the distance of the near (&lt;i&gt;z&lt;sub&gt;n&lt;/sub&gt;&lt;/i&gt;) and far (&lt;i&gt;z&lt;sub&gt;f&lt;/sub&gt;&lt;/i&gt;) planes in world space. A narrower angle of view will project a far-away object to a scale more similar to close objects, giving a zoomed-in effect, while a wider angle makes objects shrink more relative to their distance, giving a wider field of view. The ratio between the near and far planes affects the resolution of the depth buffer. If the planes are too far apart, or the near plane too close to zero, you&#39;ll get &lt;b&gt;z-fighting&lt;/b&gt;, where the &lt;i&gt;z&lt;/i&gt; coordinates of projected triangles differ by less than the depth buffer can represent, and depth testing gives invalid results, causing nearby objects to &quot;fight&quot; for pixels along their shared edge.&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl3-view-frustum-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;From these variables, we can come up with a general function to construct a projection matrix for any &lt;b&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/View_frustum&quot;&gt;view frustum&lt;/a&gt;&lt;/b&gt;. The math is a little hairy; I&#39;ll describe what it does in broad strokes. With the camera at the origin, we can project the &lt;i&gt;z&lt;/i&gt; axis directly to &lt;i&gt;w&lt;/i&gt; axis values.  In an affine transformation matrix, the bottom row is always set to [0 0 0 1]. This leaves the &lt;i&gt;w&lt;/i&gt; axis unchanged. Changing this bottom row will cause the &lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, or &lt;i&gt;z&lt;/i&gt; axis values to project onto the &lt;i&gt;w&lt;/i&gt; axis, giving a perspective effect along the specified axis. In our case, setting that last row to [0 0 1 0] projects the &lt;i&gt;z&lt;/i&gt; axis value directly to the perspective scale on &lt;i&gt;w&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;We&#39;ll then need to remap the range on the &lt;i&gt;z&lt;/i&gt; axis from &lt;i&gt;z&lt;sub&gt;n&lt;/sub&gt;&lt;/i&gt; to &lt;i&gt;z&lt;sub&gt;f&lt;/sub&gt;&lt;/i&gt; so that it projects into the space between the near (&amp;ndash;1) and far (1) planes of projection space. Taking the effect of the &lt;i&gt;w&lt;/i&gt; coordinate into account, we&#39;ll have to map into the range from &amp;ndash;&lt;i&gt;z&lt;sub&gt;n&lt;/sub&gt;&lt;/i&gt; (which with a &lt;i&gt;w&lt;/i&gt; coordinate of &lt;i&gt;z&lt;sub&gt;n&lt;/sub&gt;&lt;/i&gt; will project to &amp;ndash;1) to &lt;i&gt;z&lt;sub&gt;f&lt;/sub&gt;&lt;/i&gt; (which with a &lt;i&gt;w&lt;/i&gt; coordinate that&#39;s also &lt;i&gt;z&lt;sub&gt;f&lt;/sub&gt;&lt;/i&gt; will project to 1). We do this by translating and scaling the &lt;i&gt;z&lt;/i&gt; axis to fit this new range. The angle of view is determined by how much we scale the &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt; axes. A scale of one gives a 45&amp;deg; angle of view; shrinking the axes gives a wider field of view, and growing them gives a narrower field, inversely proportional to the tangent of the angle of view. So that our output isn&#39;t distorted, we also scale the &lt;i&gt;y&lt;/i&gt; axis proportionally to the aspect ratio (&lt;i&gt;r&lt;/i&gt;) of the viewport.
&lt;/p&gt;
&lt;p&gt;
Let&#39;s write one last shader using the view frustum matrix function. We&#39;ll translate the rectangle to set it 3 units in front of us. In addition to rotating around the &lt;i&gt;x&lt;/i&gt; axis, we&#39;ll also change the translation over time to set it moving in a circle left to right and toward and away from us. Here&#39;s the code, from &lt;a href=&quot;http://github.com/jckarter/hello-gl-ch3/blob/master/view-frustum-rotation.v.glsl&quot;&gt;&lt;tt&gt;view-frustum-rotation.v.glsl&lt;/tt&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
#version 110

uniform float timer;

attribute vec4 position;

varying vec2 texcoord;
varying float fade_factor;

mat4 view_frustum(
    float angle_of_view,
    float aspect_ratio,
    float z_near,
    float z_far
) {
    return mat4(
        vec4(1.0/tan(angle_of_view),           0.0, 0.0, 0.0),
        vec4(0.0, aspect_ratio/tan(angle_of_view),  0.0, 0.0),
        vec4(0.0, 0.0,    (z_far+z_near)/(z_far-z_near), 1.0),
        vec4(0.0, 0.0, -2.0*z_far*z_near/(z_far-z_near), 0.0)
    );
}

mat4 scale(float x, float y, float z)
{
    return mat4(
        vec4(x,   0.0, 0.0, 0.0),
        vec4(0.0, y,   0.0, 0.0),
        vec4(0.0, 0.0, z,   0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

mat4 translate(float x, float y, float z)
{
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(x,   y,   z,   1.0)
    );
}

mat4 rotate_x(float theta)
{
    return mat4(
        vec4(1.0,         0.0,         0.0, 0.0),
        vec4(0.0,  cos(timer),  sin(timer), 0.0),
        vec4(0.0, -sin(timer),  cos(timer), 0.0),
        vec4(0.0,         0.0,         0.0, 1.0)
    );
}

void main()
{
    gl_Position = view_frustum(radians(45.0), 4.0/3.0, 0.5, 5.0)
        * translate(cos(timer), 0.0, 3.0+sin(timer))
        * rotate_x(timer)
        * scale(4.0/3.0, 1.0, 1.0)
        * position;
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
}
&lt;/pre&gt;
&lt;p&gt;And this is what we get:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl3-view-frustum-projection-screenshot.png&quot;&gt;&lt;/center&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;
Matrix multiplication is by far the most common operation in a &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; rendering pipeline. The rotation, scaling, translation, and frustum matrices we&#39;ve covered are the basic structures that make &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; graphics happen. With these fundamentals covered, we&#39;re now ready to start building &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; scenes. If you want to learn more about &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; math, the book &lt;a href=&quot;http://www.amazon.com/Primer-Graphics-Development-Wordware-Library/dp/1556229119&quot;&gt;&lt;i&gt;&lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; Math Primer for Graphics and Game Development&lt;/i&gt;&lt;/a&gt; gives excellent in-depth coverage beyond the basics I&#39;ve touched on here.
&lt;/p&gt;
&lt;p&gt;In this chapter, I&#39;ve been demonstrating matrix math by writing code completely within the vertex shader. Constructing our matrices in the vertex shader will cause the matrices to be redundantly calculated for every single vertex. For this simple four-vertex program, it&#39;s not a big deal; I stuck to GLSL because it has great support for matrix math built into the language, and demonstrating both the concepts of matrix math and a hoary C math library would make things even more confusing. Unfortunately, OpenGL provides no matrix or vector math through the C API, so we&#39;d need to use a third-party library, such as &lt;a href=&quot;http://simdx86.sourceforge.net/&quot;&gt;libSIMDx86&lt;/a&gt;, to perform this math outside of shaders. In a real program with potentially thousands of vertices, the extra matrix math overhead in the vertex shader will add up. Projection matrices generally apply to an entire scene and only need to be recalculated when the window is resized or the screen resolution changed, and model-view matrices usually change only between frames and apply to sets of vertices, so it is more efficient to precalculate these matrices and feed them to the shader as &lt;tt&gt;uniform&lt;/tt&gt;s or &lt;tt&gt;attribute&lt;/tt&gt;s. This is how we&#39;ll do things from now on.&lt;/p&gt;
&lt;p&gt;In the next chapter, we&#39;ll leave this lame &quot;hello world&quot; program behind and write a program that renders a more sophisticated &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; scene. In the process, we&#39;ll look at the next most important aspect of &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; rendering after transformation and projection: lighting.
&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html&quot;&gt;&amp;laquo; Chapter 2.3&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html&quot;&gt;Chapter 4 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-07-14T22:34:17+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Table of Contents</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html</link>
<description>
&lt;p&gt;
To make it easier for people jumping into my OpenGL tutorial from the middle, I&#39;m going to keep this post up to date with the new articles as I post them.
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html&quot;&gt;Chapter 1: The Graphics Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;Chapter 2: Hello World: The Slideshow&lt;/a&gt;&lt;/li&gt;
    &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;Chapter 2.1: Buffers and Textures&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;Chapter 2.2: Shaders&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html&quot;&gt;Chapter 2.3: Rendering&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html&quot;&gt;Chapter 3: 3D transformation and projection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html&quot;&gt;Chapter 4: Rendering a Dynamic Scene with Phong Shading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-07-14T22:33:27+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html</guid>
</item>
<item>
<title>An intro to modern OpenGL, in Chinese</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL,-in-Chinese.html</link>
<description>
&lt;p&gt;
&lt;a href=&quot;http://blog.csdn.net/kangsongrui/&quot;&gt;Kang Songrui&lt;/a&gt; is in the process of translating my &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;intro to modern OpenGL&lt;/a&gt; articles to Chinese. He recently posted his translation of the &lt;a href=&quot;http://blog.csdn.net/kangsongrui/archive/2010/04/25/5527508.aspx&quot;&gt;first chapter&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
As for chapter 4 of the English tutorial, rest assured it&#39;s coming. I&#39;ve had money-making-related projects getting in the way.
&lt;/p&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-04-26T02:25:51+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL,-in-Chinese.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 2.1: Buffers and Textures</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;&amp;laquo; Chapter 2&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;Chapter 2.2 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;Last time&lt;/a&gt;, we got a window open and awaiting the instructions that will render our hello world program. But before we actually draw anything, we&#39;ll need to supply OpenGL with our data by creating &lt;b&gt;objects&lt;/b&gt; of various kinds and uploading data into them. Let&#39;s go over the objects we&#39;ll need to set up:&lt;/p&gt;
&lt;h3&gt;The pipeline revisited&lt;/h3&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-pipeline-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
By walking through &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html#gl1-pipeline&quot;&gt;the graphics pipeline&lt;/a&gt; we went over in the first chapter again, this time from the perspective of our &quot;hello world&quot; program, it will be clear what objects we&#39;ll need. Starting from the input end, our vertex array will contain four vertices, which the vertex shader will assign to the corners of the window. The element array will compose these four vertices into a two-triangle strip, making a solid rectangle that covers the window. We will build a couple of small &lt;b&gt;buffer objects&lt;/b&gt; to hold both of these arrays in GPU memory. Our uniform state will consist of our two &quot;hello&quot; images and the fade factor used to blend them. Each of those images will need its own &lt;b&gt;texture object&lt;/b&gt;. In addition to mapping our vertices to the corners of the screen, the vertex shader will assign a set of texture coordinates to each vertex, mapping the vertex to its corresponding corner on the textures. The rasterizer will then interpolate these texture coordinates across the surface of the rectangle so that, finally, our fragment shader can sample the two textures and blend them together using the fade factor. To plug the shaders into OpenGL, we&#39;ll create a &lt;b&gt;program object&lt;/b&gt; to link together the vertex and fragment &lt;b&gt;shader objects&lt;/b&gt;. In this article, we&#39;ll set up the buffer and texture objects; next time, we&#39;ll work on the shaders.
&lt;/p&gt;
&lt;h3&gt;OpenGL C types&lt;/h3&gt;
&lt;p&gt;
OpenGL defines its own set of &lt;tt&gt;GL*&lt;/tt&gt; typedefs that mirrors the standard menagerie of C types: &lt;tt&gt;GLubyte&lt;/tt&gt;, &lt;tt&gt;GLbyte&lt;/tt&gt;, &lt;tt&gt;GLushort&lt;/tt&gt;, &lt;tt&gt;GLshort&lt;/tt&gt;, &lt;tt&gt;GLuint&lt;/tt&gt;, &lt;tt&gt;GLint&lt;/tt&gt;, &lt;tt&gt;GLfloat&lt;/tt&gt;, and &lt;tt&gt;GLdouble&lt;/tt&gt; alias their corresponding C types as you would expect. On top of this basic set of types, OpenGL provides some additional typedefs with more semantic meaning:
&lt;ul&gt;
&lt;li&gt;&lt;tt&gt;GLchar*&lt;/tt&gt;, used by functions that handle strings and expect pointers to null-terminated, ASCII strings
&lt;li&gt;&lt;tt&gt;GLclampf&lt;/tt&gt; and &lt;tt&gt;GLclampd&lt;/tt&gt;, typedefs for &lt;tt&gt;GLfloat&lt;/tt&gt; and &lt;tt&gt;GLdouble&lt;/tt&gt; used when values are expected to be in the range zero to one
&lt;li&gt;&lt;tt&gt;GLsizei&lt;/tt&gt;, an integer typedef suitable for holding the size of a memory buffer, akin to the standard C library&#39;s &lt;tt&gt;size_t&lt;/tt&gt;
&lt;li&gt;&lt;tt&gt;GLboolean&lt;/tt&gt;, a typedef for &lt;tt&gt;GLbyte&lt;/tt&gt; intended to contain a &lt;tt&gt;GL_TRUE&lt;/tt&gt; or &lt;tt&gt;GL_FALSE&lt;/tt&gt; value, similar to C++ or C99&#39;s &lt;tt&gt;bool&lt;/tt&gt;
&lt;li&gt;&lt;tt&gt;GLenum&lt;/tt&gt;, a typedef of &lt;tt&gt;GLuint&lt;/tt&gt; intended to contain a predefined &lt;tt&gt;GL_*&lt;/tt&gt; constant
&lt;li&gt;&lt;tt&gt;GLbitfield&lt;/tt&gt;, another &lt;tt&gt;GLuint&lt;/tt&gt; typedef intended to contain the bitwise-or of one or more &lt;tt&gt;GL_*_BIT&lt;/tt&gt; masks
&lt;/ul&gt;
&lt;/p&gt;
&lt;h3&gt;Storing our resources&lt;/h3&gt;
&lt;pre&gt;
&lt;a name=&quot;gl2-g-resources-buffers-textures&quot;&gt;static struct {
    GLuint vertex_buffer, element_buffer;
    GLuint textures[2];

    /* fields for shader objects ... */
} g_resources;&lt;/a&gt;
&lt;/pre&gt;
&lt;p&gt;A global struct variable like the &lt;tt&gt;g_resources&lt;/tt&gt; struct here is the easiest way to share data between our initialization code and our GLUT callbacks. OpenGL uses opaque &lt;tt&gt;GLuint&lt;/tt&gt; values for object handles. Our &lt;tt&gt;g_resources&lt;/tt&gt; struct contains two &lt;tt&gt;GLuint&lt;/tt&gt; fields we&#39;ll use to hold the names of our vertex and element array buffer objects, and a two-element array of &lt;tt&gt;GLuint&lt;/tt&gt;s for our two texture objects. We&#39;ll add more fields to hold our shader objects when we construct them in the next article.

&lt;h3&gt;&lt;a name=&quot;gl2-object-model&quot;&gt;The OpenGL object model&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;
OpenGL&#39;s convention for manipulating objects is a bit unusual. You create objects by generating one or more object &lt;b&gt;names&lt;/b&gt; using a &lt;tt&gt;glGen*s&lt;/tt&gt; function (such as &lt;tt&gt;glGenBuffers&lt;/tt&gt; or &lt;tt&gt;glGenTextures&lt;/tt&gt;). As mentioned above, these names are opaque &lt;tt&gt;GLuint&lt;/tt&gt; values. Any data owned or associated with the object is managed internally by OpenGL. That part&#39;s fairly typical. How you use the name is the unusual part: to actually manipulate an object, you first bind its name to an OpenGL-defined &lt;b&gt;target&lt;/b&gt; by calling the corresponding &lt;tt&gt;glBind*&lt;/tt&gt; function (&lt;tt&gt;glBindBuffer&lt;/tt&gt; or &lt;tt&gt;glBindTexture&lt;/tt&gt;). You then provide the &lt;i&gt;target&lt;/i&gt; as an argument to the OpenGL calls that set properties on or upload data into the bound object. Target bindings also affect related OpenGL calls that don&#39;t explicitly take the target as a parameter, as we&#39;ll see when we discuss rendering. For now, let&#39;s see how this pattern plays out when constructing buffer objects:
&lt;/p&gt;
&lt;h3&gt;Buffer objects&lt;/h3&gt;
&lt;pre&gt;
static GLuint make_buffer(
    GLenum target,
    const void *buffer_data,
    GLsizei buffer_size
) {
    GLuint buffer;
    glGenBuffers(1, &amp;buffer);
    glBindBuffer(target, buffer);
    glBufferData(target, buffer_size, buffer_data, GL_STATIC_DRAW);
    return buffer;
}
&lt;/pre&gt;
&lt;p&gt;
Buffer objects are handles to OpenGL-managed memory. Among other things, they are used to store vertex arrays (using the &lt;tt&gt;GL_ARRAY_BUFFER&lt;/tt&gt; target) and element arrays (using the &lt;tt&gt;GL_ELEMENT_ARRAY_BUFFER&lt;/tt&gt; target). When you allocate a buffer with &lt;tt&gt;glBufferData&lt;/tt&gt;, you supply a &lt;b&gt;usage hint&lt;/b&gt; that indicates how often you intend to access and change the data in the buffer, and OpenGL decides the best place in CPU or GPU memory to store its data based on that hint. The hint does not actually constrain how the buffer gets used, but using buffers against their hinted usage will lead to poor performance. For our program, we have constant vertex and element arrays that never need to change, so we give &lt;tt&gt;glBufferData&lt;/tt&gt; the &lt;tt&gt;GL_STATIC_DRAW&lt;/tt&gt; hint. The &lt;tt&gt;STATIC&lt;/tt&gt; part indicates that we don&#39;t ever intend to change the data. Buffers can also be hinted either &lt;tt&gt;DYNAMIC&lt;/tt&gt;, which indicates we intend to write into the buffer frequently, or &lt;tt&gt;STREAM&lt;/tt&gt;, which indicates we intend to regularly replace the entire contents of the buffer. The &lt;tt&gt;DRAW&lt;/tt&gt; part indicates that we intend the buffer to be read from only by the GPU. The alternatives to &lt;tt&gt;DRAW&lt;/tt&gt; are &lt;tt&gt;READ&lt;/tt&gt;, which indicates a buffer which will be primarily read back by the CPU, and &lt;tt&gt;COPY&lt;/tt&gt;, which indicates that the buffer will be a conduit between the CPU and GPU and that neither should be given preference. Vertex and element array buffers will almost always use a &lt;tt&gt;GL_*_DRAW&lt;/tt&gt; hint.
&lt;/p&gt;
&lt;pre&gt;
static const GLfloat g_vertex_buffer_data[] = { 
    -1.0f, -1.0f,
     1.0f, -1.0f,
    -1.0f,  1.0f,
     1.0f,  1.0f
};
static const GLushort g_element_buffer_data[] = { 0, 1, 2, 3 };
&lt;/pre&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-vertex-array-01.png&quot;&gt;
&lt;p&gt;&lt;tt&gt;glBufferData&lt;/tt&gt; sees your source data much as &lt;tt&gt;memcpy&lt;/tt&gt; does: just a dumb stream of bytes. We don&#39;t tell OpenGL the structure of our arrays until we actually render from them. This allows buffers to store vertex attributes and other data in almost any format, or to feed the same data in different ways to different render jobs. In our case, we just specify the corners of our rectangle as a set of four two-component vectors. Our element array is also simple, an array of &lt;tt&gt;GLushort&lt;/tt&gt;s indexing the four vertex elements in order so that they can be assembled as a rectangular triangle strip. In desktop OpenGL, an element array can consist of 8-bit &lt;tt&gt;GLubyte&lt;/tt&gt;, 16-bit &lt;tt&gt;GLushort&lt;/tt&gt;, or 32-bit &lt;tt&gt;GLuint&lt;/tt&gt; indices; for OpenGL ES, only &lt;tt&gt;GLubyte&lt;/tt&gt; or &lt;tt&gt;GLushort&lt;/tt&gt; can be used. We now fill in our &lt;tt&gt;make_resources&lt;/tt&gt; with calls to &lt;tt&gt;make_buffer&lt;/tt&gt; that allocate and fill our buffers as follows:
&lt;/p&gt;
&lt;pre&gt;
&lt;a name=&quot;gl2-make-resources-buffers&quot;&gt;static int make_resources(void)
{
    g_resources.vertex_buffer = make_buffer(
        GL_ARRAY_BUFFER,
        g_vertex_buffer_data,
        sizeof(g_vertex_buffer_data)
    );
    g_resources.element_buffer = make_buffer(
        GL_ELEMENT_ARRAY_BUFFER,
        g_element_buffer_data,
        sizeof(g_element_buffer_data)
    );
    /* make &lt;a href=&quot;#gl2-make-resources-textures&quot;&gt;textures&lt;/a&gt; and shaders ... */
}
&lt;/a&gt;&lt;/pre&gt;
&lt;h3&gt;Texture objects&lt;/h3&gt;
&lt;pre&gt;
static GLuint make_texture(const char *filename)
{
    GLuint texture;
    int width, height;
    void *pixels = read_tga(filename, &amp;width, &amp;height);

    if (!pixels)
        return 0;
&lt;/pre&gt;
&lt;p&gt;
As I mentioned in the last article, I&#39;m using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Truevision_TGA&quot;&gt;TGA format&lt;/a&gt; to store our &quot;hello world&quot; images. I won&#39;t waste time going over the parsing code here; it&#39;s in &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/util.c&quot;&gt;&lt;tt&gt;util.c&lt;/tt&gt;&lt;/a&gt; in the Github repo if you want to see it. TGA&#39;s pixel data is stored as a flat, packed, uncompressed array of three-byte &lt;a href=&quot;http://en.wikipedia.org/wiki/RGB&quot;&gt;RGB&lt;/a&gt; pixels (actually stored in BGR order), with the pixels ordered starting from the bottom left of the image and working rightward and upward from there. This format is perfect for feeding into OpenGL textures, as we&#39;ll see shortly. If reading the image file fails, we return zero, which is the &quot;null object&quot; name that will never be used by a real OpenGL object.
&lt;/p&gt;
&lt;pre&gt;
    glGenTextures(1, &amp;texture);
    glBindTexture(GL_TEXTURE_2D, texture);
&lt;/pre&gt;
&lt;p&gt;
Texture objects provide handles to structured arrays of GPU memory specialized for storing texture data. OpenGL supports several types of textures, each with its own texture target, including &lt;span class=&quot;smallcap&quot;&gt;1d&lt;/span&gt; (&lt;tt&gt;GL_TEXTURE_1D&lt;/tt&gt;), &lt;span class=&quot;smallcap&quot;&gt;2d&lt;/span&gt; (&lt;tt&gt;GL_TEXTURE_2D&lt;/tt&gt;), and &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; (&lt;tt&gt;GL_TEXTURE_3D&lt;/tt&gt;) textures. There are also some more specialized texture types we might run into later. &lt;span class=&quot;smallcap&quot;&gt;2d&lt;/span&gt; textures are by far the most common kind. Here we generate and bind a &lt;tt&gt;GL_TEXTURE_2D&lt;/tt&gt; for one of our images. Texture objects are distinct from buffer objects, because the GPU handles texture memory very differently from buffer memory:
&lt;/p&gt;
&lt;h3&gt;Texture sampling and texture parameters&lt;/h3&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-texcoords-01.png&quot;&gt;
&lt;p&gt;Whereas the vertex array is fed to the vertex shader one element at a time, and there&#39;s no way for any execution of the vertex shader to access other elements, a texture makes its entire contents available to any invocation of either the vertex or fragment shaders. Shaders &lt;b&gt;sample&lt;/b&gt; the texture at one or more floating-point &lt;b&gt;texture coordinates&lt;/b&gt;. The elements of the texture array are distributed evenly into &lt;b&gt;texture space&lt;/b&gt;, a square spanning the coordinates (0, 0) to (1, 1) (or a line segment spanning 0&amp;ndash;1 for &lt;span class=&quot;smallcap&quot;&gt;1d&lt;/span&gt; textures, or a cube spanning (0, 0, 0)&amp;ndash;(1, 1, 1) for &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; textures). To distinguish from the &lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;, &lt;i&gt;z&lt;/i&gt; coordinates of object space, OpenGL labels the axes of texture space &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;t&lt;/i&gt;, and &lt;i&gt;r&lt;/i&gt;. The texture space square is split evenly along these axes into rectangular cells, corresponding to the width and height of the original array. The cell bordering (0, 0) maps to the first element of the texture array, and subsequent elements get distributed to cells rightward and upward across the &lt;i&gt;s&lt;/i&gt; and &lt;i&gt;t&lt;/i&gt; axes. Sampling the texture at the center of one of these cells gives the corresponding element from the texture array.&lt;/p&gt;
&lt;p&gt;Note that the &lt;i&gt;t&lt;/i&gt; axis can be thought of as increasing either upward or downward (or in any direction, really), depending on the representation of the underlying array. The other axes of texture space are similarly arbitrary. Since TGA images store their pixels left-to-right and bottom-to-top, that&#39;s how I&#39;m depicting the axes here.&lt;/p&gt;
&lt;pre&gt;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_CLAMP_TO_EDGE);
&lt;/pre&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-texture-filter-01.png&quot;&gt;
&lt;p&gt;How sampling behaves when a texture is sampled between the centers of texture cells, or at coordinates outside of the zero-to-one range, is controlled by &lt;b&gt;texture parameters&lt;/b&gt;, set by the &lt;tt&gt;glTexParameteri&lt;/tt&gt; function. The parameters &lt;tt&gt;GL_TEXTURE_MIN_FILTER&lt;/tt&gt; and &lt;tt&gt;GL_TEXTURE_MAG_FILTER&lt;/tt&gt; control how in-between sample points are treated when the texture is sampled at a resolution lower and higher than its native resolution, respectively. We set them to &lt;tt&gt;GL_LINEAR&lt;/tt&gt; to tell the GPU to use &lt;b&gt;linear interpolation&lt;/b&gt; to smoothly blend the four elements closest to the sample point. If the user resizes our window, the texture image will then scale smoothly.  Setting the filters to &lt;tt&gt;GL_NEAREST&lt;/tt&gt; would tell the GPU to return the texture element closest to the sample point, leading to blocky, pixelated scaling.
&lt;/p&gt;
&lt;p&gt;
The &lt;tt&gt;GL_TEXTURE_WRAP_S&lt;/tt&gt; and &lt;tt&gt;GL_TEXTURE_WRAP_T&lt;/tt&gt; parameters control how coordinates beyond the zero-to-one range on their respective axes are treated; in our case, we don&#39;t plan to sample outside that range, so we use &lt;tt&gt;GL_CLAMP_TO_EDGE&lt;/tt&gt;, which clamps coordinates below zero to zero, and above one to one. A wrap value of &lt;tt&gt;GL_WRAP&lt;/tt&gt; for one or both axes would cause the texture image to be repeated infinitely through texture space along the wrapped axes.
&lt;/p&gt;
&lt;p&gt;
Describing it in abstract, texture sampling might sound like just extremely convoluted &lt;span class=&quot;smallcap&quot;&gt;2d&lt;/span&gt; array indexing. It will make more sense if we look at how our fragment shader will wind up sampling the texture:
&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-texture-rasterization-01.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
In our vertex shader, we&#39;ll assign the corners of the texture space square to our rectangle&#39;s vertices. When the rasterized size of the rectangle matches the size of the texture (that is, when our window is the same size as the image), the centers of the fragments (the crosses in the figure) will line up with the centers of our texture cells (the circles), and the fragment shader will wind up sampling the image pixel-for-pixel, as you see on the left side. If the rectangle&#39;s rasterized size doesn&#39;t match the texture, each fragment will wind up sampling between the centers of our texture cells, and the linear filtering will ensure we get a smooth gradient between the texture elements, as the right side demonstrates.
&lt;/p&gt;
&lt;h3&gt;Allocating textures&lt;/h3&gt;
&lt;pre&gt;
    glTexImage2D(
        GL_TEXTURE_2D, 0,           /* target, level of detail */
        GL_RGB8,                    /* internal format */
        width, height, 0,           /* width, height, border */
        GL_BGR, GL_UNSIGNED_BYTE,   /* external format, type */
        pixels                      /* pixels */
    );
    free(pixels);
    return texture;
}
&lt;/pre&gt;
&lt;p&gt;The &lt;tt&gt;glTexImage2D&lt;/tt&gt; (or &lt;tt&gt;-1D&lt;/tt&gt; or &lt;tt&gt;-3D&lt;/tt&gt;) function allocates memory for a texture. Textures can have multiple &lt;b&gt;levels of detail&lt;/b&gt;, sampling from a hierarchy of progressively smaller &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mipmap&quot;&gt;mipmaps&lt;/a&gt;&quot; when sampled at lower resolutions, but in our case we only supply the base level zero. Unlike &lt;tt&gt;glBufferData&lt;/tt&gt;, &lt;tt&gt;glTexImage2D&lt;/tt&gt; expects all of the format information for the allocated memory to be presented up front. The &lt;b&gt;internal format&lt;/b&gt; tells the GPU how many color components to store per texture element and at what precision. OpenGL supports all sorts of different image formats; I&#39;ll only mention what we use here. Our TGA files use 24-bit RGB pixels, in other words, they sport three 8-bit components per pixel. This corresponds to the &lt;tt&gt;GL_RGB8&lt;/tt&gt; internal format. The &lt;b&gt;width&lt;/b&gt; and &lt;b&gt;height&lt;/b&gt; count the number of texture elements along the &lt;i&gt;s&lt;/i&gt; and &lt;i&gt;t&lt;/i&gt; axes. (The &lt;i&gt;border&lt;/i&gt; argument is a relic and should always be zero.) The &lt;b&gt;external format&lt;/b&gt; and &lt;b&gt;type&lt;/b&gt; declare the component order and type of our &lt;b&gt;pixels&lt;/b&gt; argument, which points to &lt;i&gt;width&lt;/i&gt; &amp;#xd7; &lt;i&gt;height&lt;/i&gt; packed texture elements of the specified format. TGA stores its unsigned byte-sized pixel components in BGR order, so we use &lt;tt&gt;GL_BGR&lt;/tt&gt; for the external format and &lt;tt&gt;GL_UNSIGNED_BYTE&lt;/tt&gt; for the component type.
&lt;/p&gt;
&lt;p&gt;
Let&#39;s add some &lt;tt&gt;make_texture&lt;/tt&gt; calls to our &lt;tt&gt;make_resources&lt;/tt&gt; function to create our texture objects:
&lt;/p&gt;
&lt;pre&gt;
&lt;a name=&quot;gl2-make-resources-textures&quot;&gt;static int make_resources(void)
{
    /* ... make &lt;a href=&quot;#gl2-make-resources-buffers&quot;&gt;buffers&lt;/a&gt; */
    g_resources.textures[0] = make_texture(&quot;hello1.tga&quot;);
    g_resources.textures[1] = make_texture(&quot;hello2.tga&quot;);

    if (g_resources.textures[0] == 0 || g_resources.textures[1] == 0)
        return 0;
    /* make shaders ... */
}
&lt;/a&gt;&lt;/pre&gt;
&lt;h3&gt;Next time, shaders&lt;/h3&gt;
&lt;p&gt;
We now have our vertex and image data prepped and ready to launch through the graphics pipeline. The next step is to write the shaders that will steer that data through the GPU and land it on the screen. That&#39;s what we&#39;ll look at in the next part of this chapter.
&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;&amp;laquo; Chapter 2&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;Chapter 2.2 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-04-25T20:17:27+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 2.3: Rendering</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;&amp;laquo; Chapter 2.2&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html&quot;&gt;Chapter 3 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;
At this point in our &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;&quot;hello world&quot; program&lt;/a&gt;, we&#39;ve &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;loaded our buffers and textures&lt;/a&gt; and &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;compiled and linked our shader program&lt;/a&gt;. The pieces are all finally in place&amp;mdash;let&#39;s render our image.
&lt;/p&gt;
&lt;h3&gt;Overview of a rendering job&lt;/h3&gt;
&lt;p&gt;
Rendering potentially takes a lot of parameters. In addition to all of the buffers, textures, shaders, and uniform parameters it may involve, there are dozens of miscellaneous settings I haven&#39;t touched on that control how a rendering job behaves. Rather than offer a monolithic &quot;draw&quot; function with all of these flags as arguments, or require you to fill out a struct with dozens of fields, OpenGL&#39;s approach is to lay all of these settings out as a state machine. When you bind objects to targets using &lt;tt&gt;glBindTexture&lt;/tt&gt;, &lt;tt&gt;glBindBuffer&lt;/tt&gt;, and their kin, you are not only making the objects available for modification, you are also binding them to the current rendering job&#39;s state. There are also state manipulation functions that set the current shader program, assign values to uniform parameters, and describe the structure of the vertex array. When you finally submit a job with &lt;tt&gt;glDrawElements&lt;/tt&gt;, OpenGL takes a snapshot of the current state and adds it to the GPU&#39;s command queue, where it will be executed as soon as the GPU is available. Meanwhile, you can change the OpenGL state around and queue up additional jobs without waiting for your previous jobs to finish. Once you&#39;re done queueing up jobs, you tell the window system to &quot;swap buffers&quot;, which will wait for all of the queued jobs to finish and then commit the result to the screen.
&lt;/p&gt;
&lt;p&gt;Let&#39;s start writing the code to set up our rendering job state:&lt;/p&gt;
&lt;h3&gt;Activating the shader program and assigning uniforms&lt;/h3&gt;
&lt;pre&gt;
static void render(void)
{
    glUseProgram(g_resources.program);
&lt;/pre&gt;
&lt;p&gt;We begin by activating our shader program by passing the name of the linked program object to &lt;tt&gt;glUseProgram&lt;/tt&gt;. Once the program is active, we can start assigning values to our uniform variables. If you recall from looking at &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html#gl2-fragment-shader&quot;&gt;our fragment shader source&lt;/a&gt;, we have the &lt;tt&gt;float fade_factor&lt;/tt&gt; and an array of two &lt;tt&gt;sampler2D&lt;/tt&gt;s named &lt;tt&gt;textures&lt;/tt&gt; to assign.&lt;/p&gt;
&lt;pre&gt;
    glUniform1f(g_resources.uniforms.fade_factor, g_resources.fade_factor);
&lt;/pre&gt;
&lt;p&gt;
OpenGL provides a family of &lt;tt&gt;glUniform*&lt;/tt&gt; functions for assigning to uniform variables, with each member corresponding to a possible type for a uniform variable in a GLSL program. These functions all have names of the form &lt;tt&gt;glUniform{dim}{type}&lt;/tt&gt;, where the &lt;tt&gt;dim&lt;/tt&gt; indicates the size of a vector type (&lt;tt&gt;1&lt;/tt&gt; for an &lt;tt&gt;int&lt;/tt&gt; or &lt;tt&gt;float&lt;/tt&gt; uniform, &lt;tt&gt;2&lt;/tt&gt; for a &lt;tt&gt;vec2&lt;/tt&gt;, etc.), and the &lt;tt&gt;type&lt;/tt&gt; indicates the component type: either &lt;tt&gt;i&lt;/tt&gt; for integer, or &lt;tt&gt;f&lt;/tt&gt; for floating-point. Our &lt;tt&gt;fade_factor&lt;/tt&gt; uniform is a simple &lt;tt&gt;float&lt;/tt&gt;, so we assign it by calling &lt;tt&gt;glUniform1f&lt;/tt&gt;, passing in the uniform&#39;s location and new value as arguments.&lt;/p&gt;
&lt;pre&gt;
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, g_resources.textures[0]);
    glUniform1i(g_resources.uniforms.textures[0], 0);

    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, g_resources.textures[1]);
    glUniform1i(g_resources.uniforms.textures[1], 1);
&lt;/pre&gt;
&lt;p&gt;
Assigning textures to &lt;tt&gt;sampler&lt;/tt&gt;s is a bit more complicated. The GPU has a limited number of &lt;b&gt;texture units&lt;/b&gt; that can supply texture data to any one rendering job. We have to bind our texture objects to these texture units, then assign the indexes of the texture units to our &lt;tt&gt;sampler&lt;/tt&gt; uniform variables as if they were &lt;tt&gt;int&lt;/tt&gt; variables. The &lt;tt&gt;GL_TEXTURE_*&lt;/tt&gt; target name we bind to must also correspond to the type of the &lt;tt&gt;sampler&lt;/tt&gt; uniform. In our case, &lt;tt&gt;GL_TEXTURE_2D&lt;/tt&gt; corresponds to the &lt;tt&gt;sampler2D&lt;/tt&gt; type of our &lt;tt&gt;textures&lt;/tt&gt; variable. &lt;tt&gt;glActiveTexture&lt;/tt&gt; sets the active texture unit. &lt;tt&gt;glBindTexture&lt;/tt&gt; takes the active texture unit as an implicit parameter, binding the given texture object to the target on that unit. (Other texture object manipulation functions like &lt;tt&gt;glTexParameteri&lt;/tt&gt; and &lt;tt&gt;glTexImage2D&lt;/tt&gt; also operate on the texture bound to the active texture unit.) Once we&#39;ve bound the texture unit, we can assign its index to the uniform using &lt;tt&gt;glUniform1i&lt;/tt&gt;.
&lt;/p&gt;
&lt;h3&gt;Setting up the vertex array&lt;/h3&gt;
&lt;pre&gt;
    glBindBuffer(GL_ARRAY_BUFFER, g_resources.vertex_buffer);
    glVertexAttribPointer(
        g_resources.attributes.position,  /* attribute */
        2,                                /* size */
        GL_FLOAT,                         /* type */
        GL_FALSE,                         /* normalized? */
        sizeof(GLfloat)*2,                /* stride */
        (void*)0                          /* array buffer offset */
    );
    glEnableVertexAttribArray(g_resources.attributes.position);
&lt;/pre&gt;
&lt;p&gt;
Next, we tell OpenGL the format of our vertex array. We do this by going through each vertex attribute and calling &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt;, which associates a part of a vertex buffer with the attribute, and &lt;tt&gt;glEnableVertexAttribArray&lt;/tt&gt;, which tells OpenGL to read values for that attribute from the vertex array while rendering. &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt; takes as arguments the attribute location, the size and component type of the associated attribute variable (for our &lt;tt&gt;position&lt;/tt&gt; attribute, size &lt;tt&gt;2&lt;/tt&gt; and type &lt;tt&gt;GL_FLOAT&lt;/tt&gt;), the number of bytes between attribute values (called the &lt;b&gt;stride&lt;/b&gt;), and the offset of the first attribute value inside the currently bound &lt;tt&gt;GL_ARRAY_BUFFER&lt;/tt&gt;. For historic reasons, the offset is passed as a pointer, but the parameter is used for its integer value, so we pass an integer cast to &lt;tt&gt;void*&lt;/tt&gt;.
&lt;/p&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-vertex-attrib-array-01.png&quot;&gt;
&lt;p&gt;In our case, our vertex array consists only of the single &lt;tt&gt;vec2 position&lt;/tt&gt; attribute; if we had multiple attributes, the attributes&#39; values could be either interleaved, like an array of &lt;tt&gt;struct&lt;/tt&gt;s, or kept in separate arrays. The flexibility &lt;tt&gt;glVertexAttribPointer&lt;/tt&gt; gives in letting us choose the stride and offset of each attribute can accommodate either arrangement. Different attributes can even be potentially read from separate buffer objects; changing the &lt;tt&gt;GL_ARRAY_BUFFER&lt;/tt&gt; binding won&#39;t affect the buffer used by attribute array pointers that have already been set.
&lt;/p&gt;
&lt;p&gt;(The &lt;i&gt;normalized?&lt;/i&gt; argument I skipped mentioning above is used with arrays of integers in the vertex array. If true, the components will be mapped from the range of their integer type, such as 0&amp;ndash;255 for an unsigned byte, to the floating-point range 0.0&amp;ndash;1.0, like color components in an image. If false, their integer values will be preserved. For components like ours that are already floating-point, it doesn&#39;t have any effect.)&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;Submitting the rendering job&lt;/h3&gt;
&lt;pre&gt;
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_resources.element_buffer);
    glDrawElements(
        GL_TRIANGLE_STRIP,  /* mode */
        4,                  /* count */
        GL_UNSIGNED_SHORT,  /* type */
        (void*)0            /* element array buffer offset */
    );
&lt;/pre&gt;
&lt;p&gt;
&lt;tt&gt;glDrawElements&lt;/tt&gt; is the function that sets the graphics pipeline in motion. We tell it what triangle assembly mode we want, how many vertices to assemble triangles from, the type of the components of our element array, and the offset within the currently bound &lt;tt&gt;GL_ELEMENT_ARRAY_BUFFER&lt;/tt&gt; of the first component to render, again as a fake-pointer-but-really-integer. It will then take the pointed-to element array indexes, gather them up with the currently bound shader program, uniform values, texture units, and vertex attribute pointers we just set up, bundle everything into a rendering job, and place the job in the GPU&#39;s queue.
&lt;/p&gt;

&lt;h3&gt;Cleaning up after ourselves&lt;/h3&gt;
&lt;pre&gt;
    glDisableVertexAttribArray(g_resources.attributes.position);
&lt;/pre&gt;
&lt;p&gt;&quot;Always leave things the way you found them,&quot; the late Bill Brasky once advised. A downside of OpenGL&#39;s state machine model is that all of these bindings and settings persist globally, even after &lt;tt&gt;glDrawElements&lt;/tt&gt; is called. This means that we have to take some care with how our OpenGL code will interact with all of the other OpenGL code throughout the program. While there is no other OpenGL code yet in this program to interact with, we should still start learning good habits. Particular care is needed with vertex attributes: In a complex program involving multiple shader programs and multiple vertex arrays, an incorrectly enabled vertex attribute array could potentially cause &lt;tt&gt;glDrawElements&lt;/tt&gt; to try to feed the GPU invalid data, leading to corrupted output or segfaults. It&#39;s a good idea to keep a vertex array attribute enabled only as long as it&#39;s needed. Here, we disable the vertex attribute array for &lt;tt&gt;position&lt;/tt&gt;.
&lt;/p&gt;
&lt;p&gt;
You might also be thinking, we&#39;re rebinding all of the same objects, setting all of the same uniform values (aside from the &lt;tt&gt;fade_factor&lt;/tt&gt;), and reactivating all of the same vertex attributes every time we render. If the state settings persist across &lt;tt&gt;glDrawElements&lt;/tt&gt; calls, we could technically do without almost all of this per-frame setup, getting away with binding everything once before entering &lt;tt&gt;glutMainLoop&lt;/tt&gt; and having &lt;tt&gt;render&lt;/tt&gt; only update the fade factor and call &lt;tt&gt;glDrawElements&lt;/tt&gt;. But again, it&#39;s a good idea to set up all the state you expect at the point you expect it. Depending on bits of OpenGL state to remain unchanged between frames is an easy way to breed bugs as your programs grow.
&lt;/p&gt;

&lt;h3&gt;Displaying our finished scene&lt;/h3&gt;
&lt;pre&gt;
    glutSwapBuffers();
}
&lt;/pre&gt;
&lt;p&gt;
We only have the one rendering job to wait on, so now that we&#39;ve submitted the job and tidied up, we can sync immediately. The GLUT function &lt;tt&gt;glutSwapBuffers&lt;/tt&gt; waits for all running jobs to finish, then swaps the color buffers of our double-buffered framebuffer, moving the currently visible buffer to the &quot;back&quot; to be rendered into by the next frame, and pushing the image we just rendered to the &quot;front&quot;, showing the newly-rendered scene in our window. Our rendering is done!
&lt;/p&gt;

&lt;h3&gt;Animating the scene&lt;/h3&gt;
&lt;pre&gt;
static void update_fade_factor(void)
{
    int milliseconds = glutGet(GLUT_ELAPSED_TIME);
    g_resources.fade_factor = sinf((float)milliseconds * 0.001f) * 0.5f + 0.5f;
    glutPostRedisplay();
}
&lt;/pre&gt;
&lt;p&gt;
To keep the image moving, our &lt;tt&gt;glutIdleFunc&lt;/tt&gt; callback continuously updates the value we assign to the &lt;tt&gt;fade_factor&lt;/tt&gt; uniform. GLUT maintains a millisecond timer we can access with &lt;tt&gt;glutGet(GLUT_ELAPSED_TIME)&lt;/tt&gt;; we just feed this through the standard C &lt;tt&gt;sinf&lt;/tt&gt; function to get a smooth, periodic fade from zero to one and back. Every time we update the fade factor, we call &lt;tt&gt;glutPostRedisplay&lt;/tt&gt;, which forces our &lt;tt&gt;render&lt;/tt&gt; callback to get invoked again, updating the window.
&lt;/p&gt;

&lt;h3&gt;Compiling and running the program, again&lt;/h3&gt;
&lt;p&gt;It&#39;s finally time to compile and run the whole program with all of our new code. The command to build the executable will look much as it did &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html#gl2-compiling&quot;&gt;last time when we built the dummied-out version&lt;/a&gt;, but this time, you&#39;ll build from the real &lt;tt&gt;hello-gl.c&lt;/tt&gt; and &lt;tt&gt;util.c&lt;/tt&gt; source files. If you use the Makefiles, you can build with the default target:&lt;/p&gt;
&lt;pre&gt;
make -f Makefile.MacOSX # or Makefile.Unix or Makefile.Mingw
&lt;/pre&gt;
&lt;pre&gt;
nmake /f Nmakefile.Windows
&lt;/pre&gt;
&lt;p&gt;Once built, the program assumes that all its image and shader resources are in the current directory, so it will work best to run it from the command line from inside the directory containing the executable, the image files, and the shader source. We can finally bask in the glory of our hard work:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl2-screenshot.png&quot;&gt;&lt;/center&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That was admittedly a long way to go for a simple &quot;hello world&quot;. But the framework we&#39;ve built up here is actually pretty flexible; you could swap in your own images and tweak the shaders to transform or filter the images further before sampling them, all without recompiling the C. In the next chapter, we&#39;ll mess around with the vertex shader to demonstrate the basics of &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; transformation and projection.&lt;/p&gt;
&lt;p&gt;If you&#39;re interested in breaking off on your own at this point and looking over the &lt;a href=&quot;http://www.opengl.org/registry/&quot;&gt;OpenGL specifications&lt;/a&gt; yourself, note that the OpenGL 2 specs still include all of the deprecated features I&#39;ve been avoiding discussing. I would highly recommend looking instead at the spec for OpenGL 3.1 or later, being sure to look at the &quot;core profile&quot; specs rather than the ones for the &quot;compatibility profiles&quot;. While OpenGL 3 and later add a lot of new features over OpenGL 2, all of the basic APIs I&#39;ve gone over here for OpenGL 2 still form the basis for newer versions.
&lt;p&gt;&lt;a href=&quot;http://www.khronos.org/registry/gles/&quot;&gt;OpenGL ES&lt;/a&gt; 2 is also worth looking at. It consists mostly of the forward-looking subset of OpenGL 2 I&#39;ve been covering; all of the OpenGL APIs I&#39;ve mentioned are present in OpenGL ES 2 as well. OpenGL ES also adds additional features for mobile platforms, such as fixed-point numeric support and offline shader compilation, that the desktop version of the spec doesn&#39;t offer. If you want to try your hand at OpenGL ES development, it is part of the Android NDK and iPhone SDKs, among other mobile development platforms. On Windows, Google&#39;s &lt;a href=&quot;http://code.google.com/p/angleproject/&quot;&gt;ANGLE project&lt;/a&gt; also provides an implementation of OpenGL ES 2 built on top of DirectX.&lt;/p&gt;
&lt;p&gt;Hopefully this chapter has given you a good taste of the OpenGL API and GLSL language. As always, if you felt something I touched on bears clarification, or there&#39;s something in particular you&#39;d like to see me cover, &lt;script&gt;male_to(&#39;com&#39;, &#39;joe&#39;, &#39;duriansoftware&#39;, &#39;drop me a line&#39;)&lt;/script&gt;.
&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html&quot;&gt;&amp;laquo; Chapter 2.2&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html&quot;&gt;Chapter 3 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-04-25T20:13:38+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 2: Hello World: The Slideshow</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html&quot;&gt;&amp;laquo; Chapter 1&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;Chapter 2.1 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;
&lt;b&gt;Updates:&lt;/b&gt; I&#39;ve fixed a few problems people have reported, particularly problems building on Unix and using Visual C++. This chapter also got featured &lt;a href=&quot;http://www.reddit.com/r/programming/comments/biw8t/an_intro_to_modern_opengl_chapter_2_hello_world/&quot;&gt;on Reddit&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
In the &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html&quot;&gt;previous chapter&lt;/a&gt; I gave a big-picture overview of the graphics pipeline. Now it&#39;s time to put it into action. Before we try rendering any fancy &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; scenes, I&#39;ll follow standard tutorial protocol and use a simple, two-dimensional &quot;hello world&quot; app to demonstrate the basics of the OpenGL API. We&#39;re going to take this image:
&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-hello-1.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
and draw it to an appropriately-sized window. But static images are kind of dull&amp;mdash;how about we make it a little more interesting by fading back and forth with this image:
&lt;/p&gt;
&lt;center&gt;&lt;img class=&quot;figure&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-hello-2.png&quot;&gt;&lt;/center&gt;
&lt;p&gt;
Still not all that exciting a program, but despite its simplicity, the program will exercise almost all the parts of OpenGL a more complex program would. The completed source code is up on Github &lt;a href=&quot;http://github.com/jckarter/hello-gl&quot;&gt;here&lt;/a&gt;. At 380 lines of C and a couple dozen lines of shader code, this program may seem like overkill just to draw an image to the screen. However, much of it will lay the groundwork for the more interesting demos to come. The &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl.c&quot;&gt;&lt;tt&gt;hello-gl.c&lt;/tt&gt;&lt;/a&gt; source file contains the OpenGL rendering bits, while &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/util.c&quot;&gt;&lt;tt&gt;util.c&lt;/tt&gt;&lt;/a&gt; contains boring utility functions for reading TGA image files. I&#39;ve included the two images, &lt;tt&gt;hello1.tga&lt;/tt&gt; and &lt;tt&gt;hello2.tga&lt;/tt&gt;, in this format, because it&#39;s easy to parse without depending on an external library. Our shader code lives in two files: &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl.v.glsl&quot;&gt;&lt;tt&gt;hello-gl.v.glsl&lt;/tt&gt;&lt;/a&gt; for the vertex shader, and &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl.f.glsl&quot;&gt;&lt;tt&gt;hello-gl.f.glsl&lt;/tt&gt;&lt;/a&gt; for the fragment shader.
&lt;/p&gt;
&lt;p&gt;
In this chapter, I&#39;ll explain how the different parts of the &lt;tt&gt;hello-gl&lt;/tt&gt; program use the OpenGL API to feed data into the graphics pipeline and put it in action. I&#39;ll also give a brief overview of the GLSL language when we look at shaders. It&#39;s a lot to cover all in one blog post, so I&#39;ll break the chapter up into four parts. In this first part, we&#39;ll get a window open with GLUT. In the second part, we&#39;ll set up the buffer and texture objects that will contain the raw vertex and image data for our program. After that, we&#39;ll write the shader code that will process that data into our final image on screen, and then feed the shader into OpenGL. In the final article, we&#39;ll go through the OpenGL calls that actually render to the screen. Now that our game plan&#39;s laid out, let&#39;s start putting the players on the field. We&#39;ll start things off by setting up GLUT and getting an empty window up on the screen.
&lt;/p&gt;
&lt;h3&gt;OpenGL header files&lt;/h3&gt;
&lt;pre&gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;GL/glew.h&amp;gt;
#ifdef __APPLE__
#  include &amp;lt;GLUT/glut.h&amp;gt;
#else
#  include &amp;lt;GL/glut.h&amp;gt;
#endif
&lt;/pre&gt;
&lt;p&gt;Different platforms keep their OpenGL headers in different places, but with GLEW, you don&#39;t need to worry about that. Including &lt;tt&gt;GL/glew.h&lt;/tt&gt; will pull in the system OpenGL headers for you, wherever they may live. Unfortunately, including GLUT still requires you to manually step around some cross-platform landmines. Its header traditionally lives in &lt;tt&gt;GL/glut.h&lt;/tt&gt;, but MacOS X&#39;s bundled GLUT framework uses Apple&#39;s own header file convention, putting the GLUT header in &lt;tt&gt;GLUT/glut.h&lt;/tt&gt;. There&#39;s also a bug in the way recent versions of Visual Studio&#39;s standard C headers interact with &lt;tt&gt;glut.h&lt;/tt&gt; that requires &lt;tt&gt;stdlib.h&lt;/tt&gt; to be included before it.
&lt;/p&gt;

&lt;h3&gt;Setting up our window with GLUT&lt;/h3&gt;
&lt;pre&gt;
int main(int argc, char** argv)
{
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutInitWindowSize(400, 300);
    glutCreateWindow(&quot;Hello World&quot;);
    glutDisplayFunc(&amp;render);
    glutIdleFunc(&amp;update_fade_factor);
&lt;/pre&gt;
&lt;p&gt;
GLUT provides a limited, but straightforward and portable, interface to the window system. After prepping GLUT by calling &lt;tt&gt;glutInit&lt;/tt&gt;, we use &lt;tt&gt;glutInitDisplayMode&lt;/tt&gt; to specify what buffers our default framebuffer should have. In our case, a color buffer (&lt;tt&gt;GLUT_RGB&lt;/tt&gt;) with double buffering (&lt;tt&gt;GLUT_DOUBLE&lt;/tt&gt;) is sufficient. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Double_buffering#Double_buffering_in_computer_graphics&quot;&gt;Double buffering&lt;/a&gt; provides two color buffers to the framebuffer, alternating which buffer is displayed onscreen and which buffer is drawn into every frame so that animation appears smooth.) If we needed a depth or stencil buffer, we could also ask for them here. We then set the initial size for our window to the 400&amp;#xd7;300 size of our images with &lt;tt&gt;glutInitWindowSize&lt;/tt&gt; and create the window with &lt;tt&gt;glutCreateWindow&lt;/tt&gt;. Finally, we designate two callbacks to receive window events: a &lt;tt&gt;glutDisplayFunc&lt;/tt&gt; to render our image when the window needs displaying, and a &lt;tt&gt;glutIdleFunc&lt;/tt&gt; to continuously update the fade factor between the two images over time.
&lt;/p&gt;
&lt;pre&gt;
    glewInit();
    if (!GLEW_VERSION_2_0) {
        fprintf(stderr, &quot;OpenGL 2.0 not available\n&quot;);
        return 1;
    }
&lt;/pre&gt;
&lt;p&gt;
After GLUT creates our window, it prepares OpenGL so that we can start making calls into the library. The first thing we do is initialize GLEW. When &lt;tt&gt;glewInit&lt;/tt&gt; is called, it sets a bunch of flags based on what extensions and OpenGL versions are available. We check the &lt;tt&gt;GLEW_VERSION_2_0&lt;/tt&gt; flag here to ensure we have OpenGL 2.0 available before proceeding. Besides the version flags it sets, GLEW&#39;s role is mostly invisible, and we won&#39;t need to interact with it after it&#39;s been initialized.
&lt;/p&gt;
&lt;pre&gt;
    if (!make_resources()) {
        fprintf(stderr, &quot;Failed to load resources\n&quot;);
        return 1;
    }

    glutMainLoop();
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;With GLEW initialized, we call our &lt;tt&gt;make_resources&lt;/tt&gt; function to set up our OpenGL resources. We&#39;ll build up that function over the next few parts of this chapter. If our resources load successfully, &lt;tt&gt;glutMainLoop&lt;/tt&gt; takes over. It displays the window, starts receiving UI events from the window system, and invokes the callbacks we set up in response to those events. It will also exit the program for us when the user quits. The &lt;tt&gt;return 0&lt;/tt&gt; merely suppresses compiler warnings and never actually gets reached.
&lt;/p&gt;
&lt;h3&gt;Compiling and running our program&lt;/h3&gt;
&lt;p&gt;
At this point, we can stub out our GLUT callbacks and &lt;tt&gt;make_resources&lt;/tt&gt; function and get a working, if pointless, program:
&lt;/p&gt;
&lt;pre&gt;
static int make_resources(void)
{
    return 1;
}
&lt;/pre&gt;
&lt;pre&gt;
static void update_fade_factor(void)
{
}
&lt;/pre&gt;
&lt;pre&gt;
static void render(void)
{
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    glutSwapBuffers();
}
&lt;/pre&gt;
&lt;p&gt;
&lt;a name=&quot;gl2-compiling&quot;&gt;&lt;tt&gt;glClearColor&lt;/tt&gt; sets an &lt;a href=&quot;http://en.wikipedia.org/wiki/RGBA&quot;&gt;RGBA&lt;/a&gt; clear color (in this case, white), which &lt;tt&gt;glClear&lt;/tt&gt; then uses to fill the framebuffer&#39;s color buffer. &lt;tt&gt;glutSwapBuffers&lt;/tt&gt; then brings our cleared color buffer to the screen. With these stubs in place, we can now compile and run our program. This stubbed-out version is in the Github repo as &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl-dummy.c&quot;&gt;&lt;tt&gt;hello-gl-dummy.c&lt;/tt&gt;&lt;/a&gt;. The command to compile the program and link it to the OpenGL, GLUT, and GLEW libraries will vary across platforms. On most Unixes it should look something like this:
&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
gcc -o hello-gl-dummy hello-gl-dummy.c \
    -I/usr/X11R6/include -L/usr/X11R6/lib \
    -lGL -lGLEW -lglut
&lt;/pre&gt;
&lt;p&gt;On MacOS X:&lt;/p&gt;
&lt;pre&gt;
# Assuming GLEW was installed to /opt/local
gcc -o hello-gl-dummy hello-gl-dummy.c \
    -I/opt/local/include -L/opt/local/lib \
    -framework OpenGL -framework GLUT -lGLEW
&lt;/pre&gt;
&lt;p&gt;On Windows with Visual C++:&lt;/p&gt;
&lt;pre&gt;
cl /Fohello-gl-dummy.obj /c hello-gl-dummy.c
link /out:hello-gl-dummy.exe hello-gl-dummy.obj \
    opengl32.lib glut32.lib glew32.lib
&lt;/pre&gt;
&lt;p&gt;On Windows with mingw:&lt;/p&gt;
&lt;pre&gt;
gcc -o hello-gl-dummy.exe hello-gl-dummy.c \
    -lopengl32 -lglut32 -lglew32
&lt;/pre&gt;
&lt;p&gt;
The repo also includes makefiles for each of these platform groups. You can build this version of the program using the &lt;tt&gt;hello-gl-dummy&lt;/tt&gt; (or &lt;tt&gt;hello-gl-dummy.exe&lt;/tt&gt; on Windows):
&lt;/p&gt;
&lt;pre&gt;
make -f Makefile.MacOSX hello-gl-dummy # or Makefile.Unix or Makefile.Mingw
&lt;/pre&gt;
&lt;pre&gt;
nmake /f Nmakefile.Windows hello-gl-dummy.exe
&lt;/pre&gt;
&lt;p&gt;Once you&#39;ve built the program, you should then be able to run the program and get a white window, as promised:
&lt;center&gt;&lt;img src=&quot;http://duriansoftware.com/joe/media/gl2-dummy-screenshot.png&quot;&gt;&lt;/center&gt;
Close the window, or on MacOS X quit the application, to dismiss it.
&lt;/p&gt;
&lt;h3&gt;Next time, buffers and textures&lt;/h3&gt;
&lt;p&gt;
With the red tape of getting a window open out of the way, we&#39;re ready to actually feed our vertexes and images into OpenGL. In the next article, I&#39;ll introduce OpenGL&#39;s buffer and texture objects.
&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html&quot;&gt;&amp;laquo; Chapter 1&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;Chapter 2.1 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;


</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-04-19T08:03:35+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html</guid>
</item>
<item>
<title>An intro to modern OpenGL. Chapter 2.2: Shaders</title>
<link>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html</link>
<description>
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;&amp;laquo; Chapter 2.1&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html&quot;&gt;Chapter 2.3 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;Buffers and textures&lt;/a&gt; contain the raw materials for an OpenGL program, but without shaders, they are inert lumps of bytes. If you recall from our overview of the &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html#gl1-pipeline&quot;&gt;graphics pipeline&lt;/a&gt;, rendering requires a vertex shader, which maps our vertices into screen space, and a fragment shader, which colors in the rasterized fragments of the resulting triangles. Shaders in OpenGL are written in a language called GLSL (GL Shading Language), which looks a lot like C. In this article, we&#39;ll lay out the shader code for our &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html&quot;&gt;&quot;hello world&quot; program&lt;/a&gt; and then write the C code to load, compile, and link it into OpenGL.
&lt;/p&gt;
&lt;h3&gt;The vertex shader&lt;/h3&gt;
&lt;p&gt;Here is the GLSL source code for our vertex shader, from &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl.v.glsl&quot;&gt;&lt;tt&gt;hello-gl.v.glsl&lt;/tt&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
#version 110

attribute vec2 position;

varying vec2 texcoord;

void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
    texcoord = position * vec2(0.5) + vec2(0.5);
}
&lt;/pre&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-vertex-shader-01.png&quot;&gt;
&lt;p&gt;I&#39;ll summarize what the shader does, then give a little more detail about the GLSL language. The shader first assigns the vertex&#39;s screen space position to &lt;tt&gt;gl_Position&lt;/tt&gt;, a predefined variable that GLSL provides for the purpose. In screen space, the coordinates (&amp;ndash;1, &amp;ndash;1) and (1, 1) correspond respectively to the lower-left and upper-right corners of the framebuffer; since our vertex array&#39;s vertices already trace that same rectangle, we can directly copy the &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt; components from each vertex&#39;s &lt;tt&gt;position&lt;/tt&gt; value as it comes out of the vertex array. &lt;tt&gt;gl_Position&lt;/tt&gt;&#39;s other two vector components are used in depth testing and perspective projection; we&#39;ll look at them closer next chapter when we get into &lt;span class=&quot;smallcap&quot;&gt;3d&lt;/span&gt; math. For now, we just fill them with their identity values zero and one. The shader then does some math to map our screen-space &lt;tt&gt;position&lt;/tt&gt;s from screen space (&amp;ndash;1 to 1) to texture space (0 to 1) and assigns the result to the vertex&#39;s &lt;tt&gt;texcoord&lt;/tt&gt;.
&lt;/p&gt;
&lt;p&gt;Much like C, a GLSL shader starts executing from the &lt;tt&gt;main&lt;/tt&gt; function, which in GLSL&#39;s case takes no arguments and returns &lt;tt&gt;void&lt;/tt&gt;. GLSL borrows the C preprocessor syntax for its own directives. The &lt;tt&gt;#version&lt;/tt&gt; directive indicates the GLSL version of the following source code; our &lt;tt&gt;#version&lt;/tt&gt; declares that we&#39;re using GLSL 1.10. (GLSL versions are pretty tightly tied to OpenGL versions; 1.10 is the version that corresponds to OpenGL 2.0.) GLSL does away with pointers and most of C&#39;s sized numeric types, keeping only the &lt;tt&gt;bool&lt;/tt&gt;, &lt;tt&gt;int&lt;/tt&gt;, and &lt;tt&gt;float&lt;/tt&gt; types in common, but it adds a suite of vector and matrix types up to four components in length. The &lt;tt&gt;vec2&lt;/tt&gt; and &lt;tt&gt;vec4&lt;/tt&gt; types you see here are two- and four-component vectors of &lt;tt&gt;float&lt;/tt&gt;s, respectively. A type name can also be used as a constructor function for that type; you can construct a vector from either a single scalar value, which will be repeated into all the components of the vector, or from a combination of vectors and scalars, whose components will be strung together to form a larger vector. GLSL&#39;s math operators and many of its builtin functions are defined on these vector types to do component-wise math. In addition to numeric types, GLSL also supplies special &lt;tt&gt;sampler&lt;/tt&gt; data types for sampling textures, which we&#39;ll see in the fragment shader below. These basic types can be aggregated into array and user-defined &lt;tt&gt;struct&lt;/tt&gt; types.
&lt;/p&gt;
&lt;p&gt;
A vertex shader communicates with the surrounding graphics pipeline using specially-declared global variables in the GLSL program. Its inputs come from &lt;tt&gt;uniform&lt;/tt&gt; variables, which supply values from the uniform state, and &lt;tt&gt;attribute&lt;/tt&gt; variables, which supply per-vertex attributes from the vertex array. The shader assigns its per-vertex outputs to &lt;tt&gt;varying&lt;/tt&gt; variables. GLSL predefines some varying variables to receive special outputs used by the graphics pipeline, including the &lt;tt&gt;gl_Position&lt;/tt&gt; variable we used here.
&lt;/p&gt;

&lt;h3&gt;The fragment shader&lt;/h3&gt;
&lt;p&gt;Now let&#39;s look at the fragment shader source, from &lt;a href=&quot;http://github.com/jckarter/hello-gl/blob/master/hello-gl.f.glsl&quot;&gt;&lt;tt&gt;hello-gl.f.glsl&lt;/tt&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;a name=&quot;gl2-fragment-shader&quot;&gt;#version 110

uniform float fade_factor;
uniform sampler2D textures[2];

varying vec2 texcoord;

void main()
{
    gl_FragColor = mix(
        texture2D(textures[0], texcoord),
        texture2D(textures[1], texcoord),
        fade_factor
    );
}&lt;/a&gt;
&lt;/pre&gt;
&lt;img class=&quot;figure floated&quot; src=&quot;http://duriansoftware.com/joe/media/gl2-fragment-shader-01.png&quot;&gt;
&lt;p&gt;In a fragment shader, some things change slightly. &lt;tt&gt;varying&lt;/tt&gt; variables become inputs here: Each varying variable in the fragment shader is linked to the vertex shader&#39;s varying variable of the same name, and each invocation of the fragment shader receives a rasterized version of the vertex shader&#39;s outputs for that varying variable. Fragment shaders are also given a different set of predefined &lt;tt&gt;gl_*&lt;/tt&gt; variables. &lt;tt&gt;gl_FragColor&lt;/tt&gt; is the most important, a &lt;tt&gt;vec4&lt;/tt&gt; to which the shader assigns the RGBA color value for the fragment. The fragment shader has access to the same set of &lt;tt&gt;uniform&lt;/tt&gt;s as the vertex shader, but cannot declare or access &lt;tt&gt;attribute&lt;/tt&gt; variables.&lt;/p&gt;
&lt;p&gt;Our fragment shader uses GLSL&#39;s builtin &lt;tt&gt;texture2D&lt;/tt&gt; function to sample the two &lt;tt&gt;textures&lt;/tt&gt; from uniform state at &lt;tt&gt;texcoord&lt;/tt&gt;. It then calls the builtin &lt;tt&gt;mix&lt;/tt&gt; function to combine the two texture values based on the current value of the uniform &lt;tt&gt;fade_factor&lt;/tt&gt;: zero gives only the sample from the first texture, one gives only the second texture&#39;s sample, and values in between give us a blend of the two.&lt;/p&gt;
&lt;p&gt;Now that we&#39;ve looked over the GLSL shader code, let&#39;s jump back into C and load the shaders into OpenGL.&lt;/p&gt;
&lt;h3&gt;Storing our shader objects&lt;/h3&gt;
&lt;pre&gt;
static struct {
    /* ... fields for &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html#gl2-g-resources-buffers-textures&quot;&gt;buffer and texture&lt;/a&gt; objects */
    GLuint vertex_shader, fragment_shader, program;
    
    struct {
        GLint fade_factor;
        GLint textures[2];
    } uniforms;

    struct {
        GLint position;
    } attributes;

    GLfloat fade_factor;
} g_resources;
&lt;/pre&gt;
&lt;p&gt;First, let&#39;s add some fields to our &lt;tt&gt;g_resources&lt;/tt&gt; structure to hold the names of our shader objects and program object after we construct them. Like buffers and textures, shader and program objects are named by &lt;tt&gt;GLuint&lt;/tt&gt; handles. We also add some fields to hold the integer &lt;b&gt;locations&lt;/b&gt; that we&#39;ll need to reference our shaders&#39; uniform and attribute variables. Finally, we add a field to hold the floating-point value we&#39;ll assign to the &lt;tt&gt;fade_factor&lt;/tt&gt; uniform every frame.&lt;/p&gt;
&lt;h3&gt;Compiling shader objects&lt;/h3&gt;
&lt;pre&gt;
static GLuint make_shader(GLenum type, const char *filename)
{
    GLint length;
    GLchar *source = file_contents(filename, &amp;length);
    GLuint shader;
    GLint shader_ok;

    if (!source)
        return 0;
&lt;/pre&gt;
&lt;p&gt;OpenGL compiles shader objects from their GLSL source code and keeps the generated GPU machine code to itself. There is no standard way to precompile a GLSL program into a binary&amp;mdash;you build the shader from source every time. Here we read our shader source out of a separate file, which lets us change the shader source without recompiling our C.&lt;/p&gt;
&lt;pre&gt;
    shader = glCreateShader(type);
    glShaderSource(shader, 1, (const GLchar**)&amp;source, &amp;length);
    free(source);
    glCompileShader(shader);
&lt;/pre&gt;
&lt;p&gt;Shader and program objects deviate from the &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html#gl2-object-model&quot;&gt;&lt;tt&gt;glGen&lt;/tt&gt;-and-&lt;tt&gt;glBind&lt;/tt&gt; protocol&lt;/a&gt; that buffer and texture objects follow. Unlike buffer and texture functions, functions that operate on shaders and programs take the object&#39;s integer name directly as an argument. The objects don&#39;t need to be bound to any target to be modified. Here, we create a shader object by calling &lt;tt&gt;glCreateShader&lt;/tt&gt; with the shader type (either &lt;tt&gt;GL_VERTEX_SHADER&lt;/tt&gt; or &lt;tt&gt;GL_FRAGMENT_SHADER&lt;/tt&gt;). We then supply an array of one or more pointers to strings of source code to &lt;tt&gt;glShaderSource&lt;/tt&gt;, and tell OpenGL to compile the shader with &lt;tt&gt;glCompileShader&lt;/tt&gt;. This step is analogous to the compilation stage of a C build process; a compiled shader object is akin to a &lt;tt&gt;.o&lt;/tt&gt; or &lt;tt&gt;.obj&lt;/tt&gt; file. Just as in a C project, any number of vertex and fragment shader objects can be linked together into a working program, with each shader object referencing functions defined in the others of the same type, as long as the referenced functions all resolve and a &lt;tt&gt;main&lt;/tt&gt; entry point is provided for both the vertex and fragment shaders.&lt;/p&gt;

&lt;pre&gt;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;shader_ok);
    if (!shader_ok) {
        fprintf(stderr, &quot;Failed to compile %s:\n&quot;, filename);
        show_info_log(shader, glGetShaderiv, glGetShaderInfoLog);
        glDeleteShader(shader);
        return 0;
    }
    return shader;
}
&lt;/pre&gt;
&lt;p&gt;
Also just like a C program, a block of shader source code can fail to compile due to syntax errors, references to nonexistent functions, or type mismatches. OpenGL maintains an &lt;b&gt;info log&lt;/b&gt; for every shader object that contains errors or warnings raised by the GLSL compiler. After compiling the shader, we need to check its &lt;tt&gt;GL_COMPILE_STATUS&lt;/tt&gt; with &lt;tt&gt;glGetShaderiv&lt;/tt&gt;. If the compile fails, we display the info log using our &lt;tt&gt;show_info_log&lt;/tt&gt; function and give up. Here&#39;s how &lt;tt&gt;show_info_log&lt;/tt&gt; looks:
&lt;/p&gt;
&lt;pre&gt;
static void show_info_log(
    GLuint object,
    PFNGLGETSHADERIVPROC glGet__iv,
    PFNGLGETSHADERINFOLOGPROC glGet__InfoLog
)
{
    GLint log_length;
    char *log;

    glGet__iv(object, GL_INFO_LOG_LENGTH, &amp;log_length);
    log = malloc(log_length);
    glGet__InfoLog(object, log_length, NULL, log);
    fprintf(stderr, &quot;%s&quot;, log);
    free(log);
}
&lt;/pre&gt;
&lt;p&gt;We pass in the &lt;tt&gt;glGetShaderiv&lt;/tt&gt; and &lt;tt&gt;glGetShaderInfoLog&lt;/tt&gt; functions as arguments to &lt;tt&gt;show_info_log&lt;/tt&gt; so we can reuse the function for program objects further on. (Those &lt;tt&gt;PFNGL*&lt;/tt&gt; function pointer type names are provided by GLEW.) We use &lt;tt&gt;glGetShaderiv&lt;/tt&gt; with the &lt;tt&gt;GL_INFO_LOG_LENGTH&lt;/tt&gt; parameter to get the length of the info log, allocate a buffer to hold it, and download the contents using &lt;tt&gt;glGetShaderInfoLog&lt;/tt&gt;.&lt;/p&gt;

&lt;h3&gt;Linking program objects&lt;/h3&gt;
&lt;pre&gt;
static GLuint make_program(GLuint vertex_shader, GLuint fragment_shader)
{
    GLint program_ok;

    GLuint program = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);
&lt;/pre&gt;
&lt;p&gt;
If shader objects are the object files of the GLSL build process, then program objects are the finished executables. We create a program object using &lt;tt&gt;glCreateProgram&lt;/tt&gt;, attach shader objects to be linked into it with &lt;tt&gt;glAttachShader&lt;/tt&gt;, and set off the link process with &lt;tt&gt;glLinkProgram&lt;/tt&gt;.
&lt;/p&gt;

&lt;pre&gt;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;program_ok);
    if (!program_ok) {
        fprintf(stderr, &quot;Failed to link shader program:\n&quot;);
        show_info_log(program, glGetProgramiv, glGetProgramInfoLog);
        glDeleteProgram(program);
        return 0;
    }
    return program;
}
&lt;/pre&gt;
&lt;p&gt;Of course, linking can also fail, due to functions being referenced but not defined, missing &lt;tt&gt;main&lt;/tt&gt;s, fragment shaders using &lt;tt&gt;varying&lt;/tt&gt; inputs not supplied by the vertex shader, and other reasons analogous to the reasons C programs fail to link. We check the program&#39;s &lt;tt&gt;GL_LINK_STATUS&lt;/tt&gt; and dump its info log using &lt;tt&gt;show_info_log&lt;/tt&gt;, this time using the program-specific &lt;tt&gt;glGetProgramiv&lt;/tt&gt; and &lt;tt&gt;glGetProgramInfoLog&lt;/tt&gt; functions.&lt;/p&gt;
&lt;p&gt;Now we can fill in the last part of &lt;tt&gt;make_resources&lt;/tt&gt; that compiles and links our shader program:&lt;/p&gt;
&lt;pre&gt;
static int make_resources(void)
{
    /* make &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html#gl2-make-resources-buffers&quot;&gt;buffers&lt;/a&gt; and &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html#gl2-make-resources-textures&quot;&gt;textures&lt;/a&gt; ... */
    g_resources.vertex_shader = make_shader(
        GL_VERTEX_SHADER,
        &quot;hello-gl.v.glsl&quot;
    );
    if (g_resources.vertex_shader == 0)
        return 0;

    g_resources.fragment_shader = make_shader(
        GL_FRAGMENT_SHADER,
        &quot;hello-gl.f.glsl&quot;
    );
    if (g_resources.fragment_shader == 0)
        return 0;

    g_resources.program = make_program(
        g_resources.vertex_shader,
        g_resources.fragment_shader
    );
    if (g_resources.program == 0)
        return 0;
&lt;/pre&gt;
&lt;h3&gt;Looking up shader variable locations&lt;/h3&gt;
&lt;pre&gt;
    g_resources.uniforms.fade_factor
        = glGetUniformLocation(g_resources.program, &quot;fade_factor&quot;);
    g_resources.uniforms.textures[0]
        = glGetUniformLocation(g_resources.program, &quot;textures[0]&quot;);
    g_resources.uniforms.textures[1]
        = glGetUniformLocation(g_resources.program, &quot;textures[1]&quot;);

    g_resources.attributes.position
        = glGetAttribLocation(g_resources.program, &quot;position&quot;);

    return 1;
}
&lt;/pre&gt;
&lt;p&gt;The GLSL linker assigns a &lt;tt&gt;GLint&lt;/tt&gt; &lt;b&gt;location&lt;/b&gt; to every &lt;tt&gt;uniform&lt;/tt&gt; value and vertex shader &lt;tt&gt;attribute&lt;/tt&gt;. Structs and arrays of uniforms or attributes get further broken down, with each field getting its own location assigned. When we render using the program, we&#39;ll need to use these integer locations when we assign values to the uniform variables and when we map parts of the vertex array to attributes. Here, we use the functions &lt;tt&gt;glGetUniformLocation&lt;/tt&gt; and &lt;tt&gt;glGetAttribLocation&lt;/tt&gt; to look up these locations, giving them the variable, struct field, or array element name as a string. We then record those locations in our program&#39;s &lt;tt&gt;g_resources&lt;/tt&gt; struct. With the program linked and the uniform and attribute locations on record, we are now ready to render using the program.&lt;/p&gt;

&lt;h3&gt;Next time, we render&lt;/h3&gt;
&lt;p&gt;I know I&#39;ve left you hanging these last couple parts without a complete, working program to run. I&#39;ll fix that in the next and final part of this chapter, when we write the code that will actually set the graphics pipeline in motion and render our scene.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html&quot;&gt;&amp;laquo; Chapter 2.1&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt; | &lt;a href=&quot;http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html&quot;&gt;Chapter 2.3 &amp;raquo;&lt;/a&gt;&lt;/h4&gt;

</description>
<dc:creator>Joe Groff</dc:creator>
<dc:date>2010-04-06T00:29:36+00:00</dc:date>
<guid>http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html</guid>
</item>

</channel>
</rss>
