<!DOCTYPE html>
<html>
<head>
<title>Joe's Blog</title>
<link rel="stylesheet" href="../durians.css">
<link rel="alternate" type="application/rss+xml" title="Durian Software: Joe's Blog" href="index.rss">
<script src="../durians.js"></script>
</head>
<body class="blog">
<div class="subtitle"><a href="index.html">Joe's blog</a></div>
<a href="../index.html"><img class="marquee" src="../durians.png"></a>
<div class="content">

<div class="sidebar">
<h4>About Me</h4>
<p>My name's Joe Groff. I'm a programmer in Portland, Oregon, USA.<br>
<br><script>male_to('com', 'joe', 'duriansoftware')</script>
<br>twitter <a href="http://twitter.com/jckarter">@jckarter</a>
<br>github <a href="http://github.com/jckarter">jckarter</a>
</p>
<h4>My Friends</h4>
<p>
<a href="http://bugsplat.info/">Peter Keen</a><br>
<a href="http://leto.net/">Jonathan Leto</a><br>
<a href="http://factor-language.blogspot.com/">Slava Pestov</a><br>
<a href="http://www.kssreeram.org/">KS Sreeram</a><br>
<a href="http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendid=189198983">The Summer Darlings</a>
</p>
</div>

<div class="blog">
<h3><a href="http://duriansoftware.com/joe/Self-aware-struct-like-types-in-C++11.html">Self-aware struct-like types in C++11</a></h3>
<h4>updated July 5, 2012 11:49:30 PDT</h4>
<p>
Even with C++11, C++ offers inadequate metaprogramming facilities for user-defined types compared
to other programming languages.  Given an arbitrary struct type, you can't iterate its fields and
get useful information like name, offset, and size, without implementing those facilities by hand.
(Nearly every would-be C++ replacement language fixes this, but they
unfortunately aren't always viable options.)
The C++11 standard library introduced the <tt>tuple</tt> template as a general-purpose
metaprogrammable composite type, but it sucks in a number of ways:
<ul>
<li>The user interface is awkward. Fields are unnamed and require integer indexing using a top-level template function, <tt>get&lt;N&gt;(tuple)</tt> instead of <tt>struct.fieldname</tt>.
<li>The implementation is not straightforward: <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/tuple">libc++'s <tt>tuple</tt> header</a> is 1054 lines, and <a href="http://gcc.gnu.org/viewcvs/trunk/libstdc%2B%2B-v3/include/std/tuple?revision=188636&view=markup">libstdc++'s</a> is 1100, and both implementations rely on several layers of internal base classes to form the user-facing <tt>tuple</tt> type.
<li>Useful techniques like <a href="http://stackoverflow.com/questions/7858817/unpacking-a-tuple-to-call-a-matching-function-pointer">passing unpacked tuple elements to a function</a> are awkward to implement.
<li><tt>tuple</tt> as specified by the standard doesn't provide <tt>constexpr</tt> elementwise construction or field access and can't be used in compile-time calculations.
</ul>
<p>Here's an alternative approach I came up with that provides a user interface nearly equivalent to primitive structs, is much easier to metaprogram with than <tt>tuple</tt>, and is easier to implement as well, requiring about 150 lines of header-only code.
I've put a sample implementation up on Github at <a href="https://github.com/jckarter/selfaware">https://<wbr>github.com/<wbr>jckarter/<wbr>selfaware</a>. Here's a rundown of how it works.
<h3>Self-aware field templates</h3>
<p>The main idea is to inherit the "struct" type from a set of field class templates, each of which defines a single field along with methods to generically access its name string, value, and type. For example, a field template named <tt>foo</tt> looks like this:
<pre>template&lt;typename T>
struct foo {
    T foo;

    // field name
    constexpr static char const *name() { return "foo"; }

    // field type
    using type = T;

    // field value generic accessor
    T &amp;value() &amp; { return this->foo; }
    T const &amp;value() const &amp; { return this->foo; }
    T &amp;&amp;value() &amp;&amp; { return this->foo; }
};</pre>
<p>A preprocessor macro can generate these for us:
<pre>#define SELFAWARE_IDENTIFIER(NAME) \
    template&lt;typename T> \
    struct NAME { \
        T NAME; \
        // field name \
        constexpr static char const *name() { return #NAME; } \
        // field type \
        using type = T; \
        // field value generic accessor \
        T &amp;value() &amp; { return this->NAME; } \
        T const &amp;value() const &amp; { return this->NAME; } \
        T &amp;&amp;value() &amp;&amp; { return this->NAME; } \
    };</pre>
<h3>The self-aware struct template</h3>
<p>The "struct" template now needs only to inherit a set of field template instances and provide some
constructors:
<pre>template&lt;typename...Fields>
struct Struct : Fields... {
    // A convenience alias for subclasses
    using struct_type = Struct;

    // Preserve default constructors
    Struct() = default;
    Struct(Struct const &amp;) = default;

    // Forwarding elementwise constructor
    template&lt;typename...T>
    constexpr Struct(T &amp;&amp;...x) : Fields{static_cast&lt;T&amp;&amp;>(x)}... {}
};</pre>
<p>A <tt>Struct</tt> type can then be used either by aliasing a <tt>Struct</tt> instance or by
inheriting an instance and its constructors.
(As of Clang 3.1 and GCC 4.7, neither compiler yet supports inheriting constructors, so
aliasing is currently more practical.)
<pre>SELFAWARE_IDENTIFIER(foo)
SELFAWARE_IDENTIFIER(bar)
// Aliasing a Struct instance
using FooBar = Struct&lt;foo&lt;int>, bar&lt;double>>;
// Inheriting a Struct instance (requires inheriting constructors)
struct FooBar2 : Struct&lt;foo&lt;int>, bar&lt;double>> { using struct_type::struct_type; };</pre>
<p>Values of the type look like normal structs to user code:
<pre>FooBar frob(int x) {
    FooBar f = {x, 0.0};
    f.foo += 1;
    f.bar += 1.0;
    return f;
}</pre>
<p>The type is <a href="http://en.cppreference.com/w/cpp/types/is_trivial">trivial</a> if its component types are trivial, and its instances can be used in compile-time calculations if its component types can, like primitive structs. (However, because it inherits
multiple nonempty types, it's not <a href="http://en.cppreference.com/w/cpp/types/is_standard_layout">standard-layout</a>, and thus not quite POD.)
<pre>static_assert(std::is_trivial&lt;FooBar>::value, "should be trivial");
static_assert(FooBar{2, 3.0}.foo + FooBar{2, 4.0}.foo == 4, "2 + 2 == 4");</pre>
<h3>Metaprogramming with self-aware structs</h3>
<p>Since the fields of the <tt>Struct</tt> template are encoded in a template parameter pack,
there's a lot you can do to it with unpack expressions and recursive templates. Here are a few
examples:

<h3>Function application</h3>
<p>Applying a function object
to a <tt>Struct</tt>'s unpacked fields is easy&mdash;just unpack the <tt>value()</tt> method
of each field superclass into a function call expression:
<pre>template&lt;typename Function, typename...Fields>
auto apply(Function &amp;&amp;f, Struct&lt;Fields...> const &amp;a_struct)
    -> decltype(f(a_struct.Fields::value()...))
{
    return f(a_struct.Fields::value()...);
}

double hypotenuse(double x, double y) { return sqrt(x*x, y*y); }

double fooBarHypotenuse(FooBar const &amp;x) { return apply(hypotenuse, x); }</pre>

<h3>Interop with <tt>tuple</tt></h3>

<p>A <tt>Struct</tt> can be converted into a <tt>tuple</tt> or <tt>tie</tt> similarly:
<pre>template&lt;typename...Fields>
auto structToTuple(Struct&lt;Fields...> const &amp;s)
    -> std::tuple&lt;typename Fields::type...>
{
    return std::make_tuple(s.Fields::value()...);
}
template&lt;typename...Fields>
void assignStructFromTuple(Struct&lt;Fields...> &amp;s,
                           std::tuple&lt;typename Fields::type...> const &amp;t)
{
    std::tie(s.Fields::value()...) = t;
}</pre>

<h3>Generating code from field metadata</h3>
<p>The <tt>Struct</tt> template can implement a static method to iterate through its fields,
passing the name string, offset, size, and type of each field to a function object in turn.
(Getting the offset unfortunately relies on undefined behavior, because C++11 restricts
<tt>offsetof</tt> to standard-layout types and provides no other well-defined means that
I know of for determining offsets independent of an instance.)

<pre>template&lt;typename...Fields>
struct Struct : Fields... {
    // ... see above ...

    // NB: relies on undefined behavior
    template&lt;typename Field>
    static std::uintptr_t offset_of() {
        return reinterpret_cast&lt;std::uintptr_t>(&amp;static_cast&lt;Struct*>(nullptr)->Field::value());
    }

    template&lt;template&lt;typename T> class Trait, typename Function>
    static void each_field(Function &amp;&amp;f)
    {
        // Unpack expressions are only allowed in argument lists and initialization lists,
        // so this expression unpacks the function call expression into the initializer list
        // for an unused array (which the optimizer is nice enough to discard)
        char pass[] = {
            (f(Fields::name(), offset_of&lt;Fields>(), sizeof(typename Fields::type),
              Trait&lt;typename Fields::type>::value()), '\0')...};
        (void)pass; // suppress unused variable warnings
    }
};</pre>

<p>Many libraries that deal with binary data have finicky APIs for describing struct layouts.
A good example is OpenGL's <a href="http://www.opengl.org/sdk/docs/man4/"><tt>gl<wbr>Vertex<wbr>Attrib<wbr>Pointer</tt></a> interface, which is used to describe
the format of vertex information in memory. The <tt>each_field</tt>
function template, paired with a traits class, can generate the correct sequence of
<tt>gl<wbr>Vertex<wbr>Attrib<wbr>Pointer</tt> automatically from a <tt>Struct</tt> instance's metadata:

<pre>struct GLVertexType { GLuint size; GLenum type; GLboolean normalized; };

// A trait class to provide glVertexAttribPointer arguments appropriate for a type
template&lt;typename> struct GLVertexTraits;
template&lt;GLuint N>
struct GLVertexTraits&lt;float[N]> {
    static GLVertexType value() { return {N, GL_FLOAT, GL_FALSE}; }
};
template&lt;GLuint N>
struct GLVertexTraits&lt;std::uint8_t[N]> {
    static GLVertexType value() { return {N, GL_UNSIGNED_BYTE, GL_TRUE}; }
};

template&lt;typename Struct>
bool bindVertexAttributes(GLuint program)
{
    _VertexAttributeBinder iter(program, sizeof(T));
    Struct::template each_field&lt;GLVertexTraits>(
        [=program](char const *name, size_t offset, size_t size, GLVertexType info) {
            GLint location = glGetAttribLocation(program, name);
            glVertexAttribPointer(location, info.size, info.type, info.normalized,
                                  sizeof(Struct), reinterpret_cast&lt;const GLvoid*>(offset));
            glEnableVertexAttribArray(location);
        });
    return iter.ok;
}</pre>

<h3>Selecting a field at runtime by string name</h3>
<p>A recursive template can generate code to pick a field at runtime from a string argument, passing the value through a function object to narrow the return type:</p>
<pre>template&lt;typename R, typename Field, typename...Fields, typename Visitor, typename...AllFields>
R _select_field(Visitor &amp;&amp;v, char const *name, Struct&lt;AllFields...> const &amp;a_struct)
{
    if (strcmp(name, Field::name()) == 0)
        return v(a_struct.Field::value());
    else
        return _select_field&lt;R, Fields...>(static_cast&lt;Visitor&amp;&amp;>(v), name, a_struct);
}

template&lt;typename R, typename Visitor, typename...AllFields>
R _select_field(Visitor &amp;&amp;v, char const *name, Struct&lt;AllFields...> const &amp;a_struct)
{
    throw std::runtime_error("bad field name");
}

template&lt;typename Visitor, typename Field, typename...AllFields>
auto select_field(Visitor &amp;&amp;v, char const *name, Struct&lt;Field, AllFields...> const &amp;a_struct)
    -> decltype(v(a_struct.Field::value()))
{
    return _select_field&lt;decltype(v(a_struct.Field::value())), Field, AllFields...>
        (static_cast&lt;Visitor&amp;&amp;>(v), name, a_struct);
}</pre>

<tt>select_field</tt> can then be used like this:

<pre>template&lt;typename T>
struct converter {
    template&lt;typename U> T operator()(U &amp;&amp;x) { return T(x); }
};

void testStructSelectField()
{
    FooBar x{11, 22.0};

    double foo = select_field(converter&lt;double>(), "foo", x);
    double bar = select_field(converter&lt;double>(), "bar", x);
    assert(foo == 11.0);
    assert(bar == 22.0);
}</pre>

<h3>Problems</h3>
<p>This technique still isn't ideal. Most obviously, field templates all need to be
defined somewhere, which adds maintenance friction, and they rely on unseemly preprocessor magic
to create. Fields and <tt>Struct</tt> instances could
perhaps be instantiated together in one macro, perhaps by pulling in <tt>boost::preprocessor</tt>.
Compile time, always an issue with C++, also suffers from use of the <tt>Struct</tt> template. Clang 3.1 takes almost a second on this 2.4 GHz Core 2 Duo just to compile the 199-line <a href="https://github.com/jckarter/selfaware/blob/master/selfaware-test.cpp"><tt>selfaware-test.cpp</tt></a> test suite. And <tt>tuple</tt>, for all its faults, is standard, and will be available on any platform
that purports to support C++11. Neither <tt>Struct</tt> nor <tt>tuple</tt> is standard-layout and
thus can't interoperate with C in a standard-guaranteed, portable way. I'd love to hear about other
approaches to enabling composite type metaprogramming in C++.


</div>
<div class="blog">
<h3><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html">An intro to modern OpenGL. Chapter 4: Rendering a Dynamic 3D Scene with Phong Shading</a></h3>
<h4>updated July 15, 2010 08:06:09 PDT</h4>
<h4><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html">&laquo; Chapter 3</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">Table of Contents</a></h4>
<p>At this point, we've seen the most important core parts of the OpenGL API and gotten a decent taste of the GLSL language. Now's a good time to start exercising OpenGL and implementing some graphic effects, introducing new nuances and specialized features of OpenGL and GLSL as we go. For the next few chapters, I've prepared a new demo program you can get from my Github <a href="http://github.com/jckarter/ch4-flag"><tt>ch4-flag</tt> repository</a>. The <tt>flag</tt> demo renders a waving flag on a flagpole against a simple background:
</p>
<center><img src="http://duriansoftware.com/joe/media/gl4-flag.png"></center>
<p>
With the flat, wallpaper-looking grass and brick textures and the unnatural lack of shadow cast by the flag, it looks like something a Nintendo 64 would have rendered, but it's a start. We'll improve the graphical fidelity of the demo over the next few chapters. For this chapter, we'll render the above image by implementing the <a href="http://en.wikipedia.org/wiki/Phong_shading"><b>Phong shading</b></a> model, which will serve as the basis for more advanced effects we'll look at later on.
</p>
<h3>Overview of the <tt>flag</tt> program</h3>
<p>
I've organized <tt>flag</tt> into four C files and four headers. You've already seen a good amount of it in <tt>hello-gl</tt>: the <a href="http://github.com/jckarter/ch4-flag/blob/master/file-util.c"><tt>file-util.c</tt></a> and <a href="http://github.com/jckarter/ch4-flag/blob/master/file-util.h"><tt>file-util.h</tt></a> files contain the <tt>read_tga</tt> and <tt>file_contents</tt> functions, and <a href="http://github.com/jckarter/ch4-flag/blob/master/gl-util.c"><tt>gl-util.c</tt></a> and <a href="http://github.com/jckarter/ch4-flag/blob/master/gl-util.h"><tt>gl-util.h</tt></a> contain the <tt>make_texture</tt>, <tt>make_shader</tt>, and <tt>make_program</tt> functions we wrote in chapter 2. The <a href="http://github.com/jckarter/ch4-flag/blob/master/gl-util.h"><tt>vec-util.h</tt></a> header contains some basic vector math functions. <a href="http://github.com/jckarter/ch4-flag/blob/master/flag.c"><tt>flag.c</tt></a> looks a lot like <tt>hello-gl.c</tt> did: in <tt>main</tt>, we initialize GLUT and GLEW, set up callbacks for GLUT events, call a <tt>make_resources</tt> function to allocate a bunch of GL resources, and call out to <tt>glutMainLoop</tt> to start running the demo. However, the setup and rendering are a bit more involved than last time. Let's look at what's new and changed:
</p>
<h3>Mesh construction</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl4-mesh-01.png">
<p>
The <a href="http://github.com/jckarter/ch4-flag/blob/master/meshes.c"><tt>meshes.c</tt></a> file contains code that generates the vertex and element arrays, collectively called a <b>mesh</b>, for the flag, flagpole, ground, and wall objects that we'll be rendering. Most objects in the real world, including real flagpoles and flags, have smooth curving surfaces, but graphics cards deal with triangles. To render these objects, we have to approximate their surfaces as a collection of triangles. We do this by filling a vertex array with vertices placed along its surface, storing attributes of the surface with each vertex, and connecting the samples into triangles using the element array to give an approximation of the original surface.
</p>
<p>The fundamental properties a mesh stores for each vertex are its <b>position</b> in world space and its <b>normal</b>, a vector perpendicular to the original surface. The normal is fundamental to shading calculations, as we'll see shortly. Normals should be <b>unit vectors</b>, that is, vectors whose length is one. Each vertex also has <b>material</b> parameters that indicate how the surface is shaded. The material can consist of a set of per-vertex values, <b>texture coordinates</b> that sample material information from a texture, or some combination of both. <p>For the <tt>flag</tt> demo, the material consists of a <b>texture coordinate</b> for sampling the <b>diffuse</b> color from the mesh texture, a <b>specular</b> color, and <b>shininess</b> factor. We'll see how these parameters are used shortly. Our vertex buffer thus contains an array of <tt>flag_vertex</tt> structs looking like this:</p>
<pre>struct flag_vertex {
    GLfloat position[4];
    GLfloat normal[4];
    GLfloat texcoord[2];
    GLfloat shininess;
    GLubyte specular[4];
};</pre>
<p>Although the position and normal are three-dimensional vectors, we pad them out to four elements because most GPUs prefer to load vector data from 128-bit-aligned buffers, like SIMD instruction sets such as SSE. For each mesh, we collect the vertex buffer, element buffer, texture object, and element count into a <tt>flag_mesh</tt> struct. When we render, we set up <tt>glVertexAttribPointer</tt>s to pass all of the <tt>flag_vertex</tt> attributes to the vertex shader:</p>
<pre> struct flag_mesh {
    GLuint vertex_buffer, element_buffer;
    GLsizei element_count;
    GLuint texture;
};</pre>
<pre>static void render_mesh(struct flag_mesh const *mesh)
{
    glBindTexture(GL_TEXTURE_2D, mesh->texture);

    glBindBuffer(GL_ARRAY_BUFFER, mesh->vertex_buffer);
    glVertexAttribPointer(
        g_resources.flag_program.attributes.position,
        3, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, position)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.normal,
        3, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, normal)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.texcoord,
        2, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, texcoord)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.shininess,
        1, GL_FLOAT, GL_FALSE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, shininess)
    );
    glVertexAttribPointer(
        g_resources.flag_program.attributes.specular,
        4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(struct flag_vertex),
        (void*)offsetof(struct flag_vertex, specular)
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->element_buffer);
    glDrawElements(
        GL_TRIANGLES,
        mesh->element_count,
        GL_UNSIGNED_SHORT,
        (void*)0
    );
}</pre>
<p>Note that the <tt>glVertexAttribPointer</tt> call for the <tt>specular</tt> color attribute passes <tt>GL_TRUE</tt> for the <i>normalized</i> argument. The specular colors are stored as four-component arrays of bytes between <tt>0</tt> and <tt>255</tt>, much as they would be in a bitmap image, but with the normalized flag set, they'll be presented to the shaders as normalized floating-point values between <tt>0.0</tt> and <tt>1.0</tt>.</p>
<p>The actual code to generate the meshes is fairly tedious, so I'll just describe it at a high level. We construct two distinct meshes: the background mesh, created by <tt>init_background_mesh</tt>, which consists of the static flagpole, ground, and wall objects; and the flag, set up by <tt>init_flag_mesh</tt>. The background mesh consists of two large rectangles for the ground and wall, and a thin cylinder with a pointed truck making the flagpole. The wall, ground, and flagpole are assigned texture coordinates to sample out of a single <b>texture atlas</b> image containing the grass, brick, and metal textures, stored in <tt>background.tga</tt>. This allows the entire background to be rendered in a single pass with the same active texture. The flagpole is additionally given a yellow specular color, which will give it a metallic sheen when we shade it. The flag is generated by evaluating the function <tt>calculate_flag_vertex</tt> at regular intervals between zero and one on the <i>s</i> and <i>t</i> parametric axes, generating something that looks sort of like a flag flapping in the breeze. The flag being a separate mesh makes it easy to update the mesh data as the flag animates, and lets us render it with its own texture, loaded from <tt>flag.tga</tt>.</p>
<h3>Streaming dynamic mesh data</h3>
<pre>void update_flag_mesh(
    struct flag_mesh const *mesh,
    struct flag_vertex *vertex_data,
    GLfloat time
) {
    GLsizei s, t, i;
    for (t = 0, i = 0; t &lt; FLAG_Y_RES; ++t)
        for (s = 0; s &lt; FLAG_X_RES; ++s, ++i) {
            GLfloat ss = FLAG_S_STEP * s, tt = FLAG_T_STEP * t;

            calculate_flag_vertex(&vertex_data[i], ss, tt, time);
        }

    glBindBuffer(GL_ARRAY_BUFFER, mesh->vertex_buffer);
    glBufferData(
        GL_ARRAY_BUFFER,
        FLAG_VERTEX_COUNT * sizeof(struct flag_vertex),
        vertex_data,
        GL_STREAM_DRAW
    );
}</pre>
<p>To animate the flag, we use our <tt>glutIdleFunc</tt> callback to recalculate the flag's vertices and update the contents of the vertex buffer. We update the buffer with the same <tt>glBufferData</tt> function we used to initialize it. However, both on initialization and on each update, we give the flag vertex data the <tt>GL_STREAM_DRAW</tt> hint instead of the <tt>GL_STATIC_DRAW</tt> hint we've been using until now. This tells the OpenGL driver to optimize for the fact that we'll be continuously replacing the buffer with new data. Since only the positions and normals of the vertices themselves changes, the element buffer for the flag can remain static. The connectivity of the vertices doesn't change.</p>
<h3>Using a depth buffer to order 3D objects</h3>
<p>Since we're drawing multiple objects in <span class="smallcap">3d</span> space, we need to ensure that objects closer to the viewer render on top of the objects behind them. An easy way to do this would be to just render the objects back-to-front&mdash;in our case, render the background mesh first, then the flag on top of it&mdash;but this is inefficient because of the <b>overdraw</b> this approach leads to: fragments get generated and processed by the fragment shader for background objects, only to be immediately overwritten by the foreground objects in front of it. Back-to-front rendering also cannot render mutually overlapping objects, such as two interlocked rings, on its own, for rendering either object first will cause it to entirely overlap the other.</p>
<p>Graphics cards use <b>depth buffers</b> to provide efficient and reliable ordering of <span class="smallcap">3d</span> objects. A depth buffer is a part of the framebuffer that sits alongside the color buffer, and like the color buffer, is a two-dimensional array of pixel values. Instead of color values, the depth buffer stores a depth value, associating a projection-space <i>z</i> coordinate to each pixel. When a triangle is rasterized with <b>depth testing</b> enabled, each fragment's projected <i>z</i> value is compared to the <i>z</i> value currently stored in the depth buffer. If the fragment would be further away from the viewer than the current depth buffer value, the fragment is discarded. Otherwise, the fragment gets rendered to the color and depth buffers, the new <i>z</i> value replacing the old depth buffer value.</p>
<p>In addition to providing correct ordering of objects, depth buffering also minimizes the cost of overdraw if you render objects front-to-back. Although the rasterizer will still generate fragments for parts of objects obscured by already-rendered objects, modern GPUs can discard these obscured fragments before they get run through the fragment shader, reducing the number of overall fragment shader invocations the processor needs to execute. Since our flag mesh appears in front of the background mesh, we thus render the flag before the background so that the obscured parts of the background don't need to be shaded.</p>
<p>To use depth testing in our program, we need to ask for a depth buffer in our framebuffer and then enable depth testing in the OpenGL state. With GLUT, we can ask for a depth buffer for a window by passing the <tt>GLUT_DEPTH</tt> flag to <tt>glutInitDisplayMode</tt>:</p>
<pre>
int main(int argc, char* argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
    /* ... */
}
</pre>
<p>We enable and disable depth testing by calling <tt>glEnable</tt> or <tt>glDisable</tt> with <tt>GL_DEPTH_TEST</tt>:</p>
<pre>static void init_gl_state(void)
{
    /* ... */
    glEnable(GL_DEPTH_TEST);
    /* ... */
}</pre>
<p>When we start rendering our scene, we need to clear the depth buffer along with the color buffer to ensure that stale depth values don't affect rendering. We can clear both buffers with a single <tt>glClear</tt> call by passing it both <tt>GL_COLOR_BUFFER_BIT</tt> and <tt>GL_DEPTH_BUFFER_BIT</tt>:</p>
<pre>static void render(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /* ... */
}</pre>
<h3>Back-face culling</h3>
<p>Another potential source of overdraw comes from within an object. If you look at the cylindrical flagpole from any direction, you're going to see at most half of its surface. The front-facing triangles appear in front of the back-facing triangles, but they rasterize into the same pixels on screen. Depending on the ordering of triangles in the mesh, the front-facing triangles will either overdraw the back-facing triangles or the fragments of the back-facing triangles will fail the depth test, requiring some extra work from the GPU in either case.</p>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl4-back-face-culling-01.png">
<p>However, we can get the GPU to cheaply and quickly discard back-facing triangles even before they get rasterized or depth-tested. If we enable <b>back-face culling</b>, the graphics card will classify every triangle as front- or back-facing after running the vertex shader and immediately prior to rasterization, completely discarding back-facing triangles. It does this by looking at the <b>winding</b> of each triangle in projection space. By default, triangles winding counterclockwise are considered front-facing. This works because transforming a triangle to face the opposite direction from the viewer reverses its winding. By constructing our meshes so that all of the triangles wind counterclockwise when viewed from the front, we can use back-face culling to eliminate most of the work of rasterizing those triangles when they face away from the viewer. Only the vertex shader will need to run for their vertices.</p>
<p>Back-face culling is enabled and disabled by passing <tt>GL_CULL_FACE</tt> to <tt>glEnable</tt>/<tt>glDisable</tt>:</p>
<pre>static void init_gl_state(void)
{
    /* ... */
    glEnable(GL_CULL_FACE);
    /* ... */
}</pre>
<h3>Updating the projection matrix and viewport</h3>
<p>If you go back a chapter and try resizing the <tt>hello-gl</tt> window, you'll notice that the image stretches to fit the new size of the window, ruining the aspect ratio we worked so hard to preserve. In order to maintain an accurate aspect ratio, we have to recalculate our projection matrix when the window size changes, taking the new aspect ratio into account. We also have to inform OpenGL of the new viewport size by calling <tt>glViewport</tt>. GLUT allows us to provide a callback that gets invoked when the window is resized using <tt>glutReshapeFunc</tt>:
<pre>static void reshape(int w, int h)
{
    g_resources.window_size[0] = w;
    g_resources.window_size[1] = h;
    update_p_matrix(g_resources.p_matrix, w, h);
    glViewport(0, 0, w, h);
}</pre>
<pre>int main(int argc, char* argv[])
{
    /* ... */
    glutReshapeFunc(&reshape);
    /* ... */
}</pre>
<p>The <tt>update_p_matrix</tt> function implements the perspective matrix formula from last chapter and stores the new projection matrix in the <tt>g_resources.p_matrix</tt> array, from which we'll feed our shaders' <tt>p_matrix</tt> uniform variable.</p>
<h3>Handling mouse and keyboard input with GLUT</h3>
<p>GLUT provides extremely primitive support for mouse and keyboard input. In <tt>flag</tt>, I've made it so that dragging the mouse moves the view around, and the view snaps back to its original position when the mouse button is released. GLUT offers a <tt>glutMotionFunc</tt> callback that gets called when the mouse moves while a button is held down and a <tt>glutMouseFunc</tt> that gets called when a mouse button is pressed or released. (There's also <tt>glutPassiveMotionFunc</tt> to handle mouse motion when a button isn't pressed, which we don't use.) Our <tt>glutMotionFunc</tt> adjusts the model-view matrix relative to the distance from the center of the window, and our <tt>glutMouseFunc</tt> resets it when the mouse button is let go:</p>
<pre>static void drag(int x, int y)
{
    float w = (float)g_resources.window_size[0];
    float h = (float)g_resources.window_size[1];
    g_resources.eye_offset[0] = (float)x/w - 0.5f;
    g_resources.eye_offset[1] = -(float)y/h + 0.5f;
    update_mv_matrix(g_resources.mv_matrix, g_resources.eye_offset);
}

static void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON && state == GLUT_UP) {
        g_resources.eye_offset[0] = 0.0f;
        g_resources.eye_offset[1] = 0.0f;
        update_mv_matrix(g_resources.mv_matrix, g_resources.eye_offset);
    }
}</pre>
<pre>int main(int argc, char* argv[])
{
    /* ... */
    glutMotionFunc(&drag);
    glutMouseFunc(&mouse);
    /* ... */
}</pre>
<p>The <tt>update_mv_matrix</tt> function is similar to <tt>update_p_matrix</tt>. It generates a translation matrix, following the formula from last chapter, and stores it to <tt>g_resources.mv_matrix</tt>, from which we feed the shaders' <tt>mv_matrix</tt> uniform variable.</p>
<p>I also rigged <tt>flag</tt> so you can reload the GLSL program from disk while the demo is running by pressing the <tt>R</tt> key. The <tt>glutKeyboardFunc</tt> callback gets called when a key is pressed. Our callback checks if the pressed key was <tt>R</tt>, and if so, calls <tt>update_flag_program</tt>:</p>
<pre>static void keyboard(unsigned char key, int x, int y)
{
    if (key == 'r' || key == 'R') {
        update_flag_program();
    }
}</pre>
<pre>int main(int argc, char* argv[])
{
    /* ... */
    glutKeyboardFunc(&keyboard);
    /* ... */
}</pre>
<p><tt>update_flag_program</tt> attempts to load, compile, and link the <tt>flag.v.glsl</tt> and <tt>flag.f.glsl</tt> files from disk, and if successful, replaces the old shader and program objects.</p>

<p>That covers the C code for the <tt>flag</tt> demo. The actual shading happens inside the GLSL code, which we'll look at next.</p>
<h3>Phong shading</h3>
<p>Physically accurate light simulation requires expensive algorithms that have only recently become possible for even high-end computer clusters to calculate in real time. Fortunately, human eyes don't require perfect physical accuracy, especially not for fast-moving animated graphics, and real-time computer graphics has come a long way rendering impressive graphics on typical consumer hardware using cheap tricks that approximate the behavior of light without simulating it perfectly. The most fundamental of these tricks is the <b>Phong shading model</b>, an inexpensive approximation of how light interacts with simple materials developed by computer graphics pioneer Bui Tuong Phong in the early 1970s. Phong shading is a <b>local illumination</b> simulation&mdash;it only considers the direct interaction between a light source and a single point. Because of this, Phong shading alone cannot calculate effects that involve the influence of other objects in a scene, such as shadows and mirror reflections. This is why the flag casts no shadow on the ground or wall behind it.</p>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl4-phong-01.png">
<p>
The Phong model involves three different lighting terms:
</p>
<ul>
<li><b>ambient</b> reflection, a constant term that simulates the background level of light;</li>
<li><b>diffuse</b> reflection, which gives the material what we usually think of as its color;</li>
<li>and <b>specular</b> reflection, the shine of polished or metallic surfaces.
</ul>
<h3>Diffuse and ambient reflection</h3>
<p>If you hold a flat sheet of paper up to a lamp in a dark room, it will appear brightest when it faces the lamp head-on, and appear dimmer as you rotate it away from the light, reaching its darkest when it's perpendicular to the light. Curved surfaces behave the same way; if you roll up or crumple the paper, its surface will be brightest where it faces the light the most directly. The wider the angle between the surface normal and the light direction, the darker the paper appears. If the paper and light remain stationary but you move your head, the paper's apparent color and brightness won't change. Likewise, in the <tt>flag</tt> demo, if you drag the view with the mouse, you can see the flag's shading remains the same. The surface reflects light evenly in every direction, or "diffusely." This basic lighting effect is thus called <b>diffuse reflection</b>.</p>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl4-phong-diffuse-01.png"></center>
<p>
There's an inexpensive operation called the <a href="http://en.wikipedia.org/wiki/Dot_product"><b>dot product</b></a> that produces a scalar value from two vectors related to the angle between them. Given two unit vectors <i>u</i> and <i>v</i>, if their dot product <i>u &#xb7; v</i> (pronounced "u dot v") is one, then the vectors face the exact same direction; if zero, they're perpendicular; and if negative one, they face exact opposite directions. Positive dot products indicate acute angles while negative dot products indicate obtuse angles. GLSL provides a function <tt>dot(u,v)</tt> to calculate the dot product of two same-sized <tt>vec</tt> values.
<p>
The dot product's behavior follows that of diffuse reflection: surfaces reflect more light the more parallel to a light source they become, or in other words, the closer the dot product of their normal and the light's direction gets to one. Perpendicular or back-facing surfaces reflect no light, and their dot product will be zero or negative. This relationship between the dot product and diffuse brightness was first observed by 18th-century physicist Johann Lambert and is referred to as <a href="http://en.wikipedia.org/wiki/Lambertian_reflectance"><b>Lambertian reflectance</b></a>, and surfaces that exhibit the behavior are called <b>Lambertian surfaces</b>. Phong shading uses Lambertian reflectance to model diffuse reflection, taking the dot product of the surface normal and the direction from the surface to the light source. If the dot product is greater than zero, it is multiplied by the diffuse color of the light, and the result is multiplied with the surface diffuse color to get the shaded result. (Multiplying two color values involves multiplying their corresponding red, green, blue, and alpha components together, which is what GLSL's <tt>*</tt> operator does when given two <tt>vec4</tt>s.) If the dot product is zero or negative, the diffuse color will be zero.
</p>
<p>
However, in the real world, even when a surface isn't directly lit, it still won't appear pitch black. In any enclosed area, there will be a certain amount of <b>ambient reflection</b> bouncing around, dimly illuminating areas that the light sources don't directly hit. The Phong model simulates the ambient effect by assigning light sources a constant ambient color. This ambient color gets added to the light's diffuse color after it's been multiplied by the dot product. The sum of ambient and diffuse effect colors is then multiplied by the surface's diffuse color to give the shaded result.
</p>

<h3>Specular reflection</h3>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl4-phong-specular-01.png"></center>
<p>Not all surfaces reflect light uniformly; many materials, including metals, glass, hair, and skin, have a reflective sheen. Unlike with diffuse reflection, if the viewer moves while a light source and shiny object remain stationary, the shine will move along the surface with the viewer. You can see this simulated in the <tt>flag</tt> demo by looking at the flagpole: as you drag the view up and down, the gold sheen moves along the pole with you. Physically, an object appears shiny when its surface is covered in highly reflective <b>microfacets</b>. These facets face every direction, creating a bright shiny spot where the light source reflects directly toward the viewer. This effect is called <b>specular reflection</b>.</p>
<p>The specular effect is caused by reflection from the light source to the viewer, so Phong shading simulates the specular effect by reflecting the light direction around the surface normal to give a reflection direction. We can then take the dot product of the reflection direction and the direction from the surface to the viewer. Microfacets on a specular surface follow a <b>normal distribution</b>: a plurality of facets lie parallel to the surface, and there is an exponential dropoff in the number of facets at steeper angles from the surface. The dropoff is sharper for more polished surfaces, giving a smaller, tighter specular highlight. Phong shading approximates this distribution by raising the dot product to an exponent called the <b>shininess factor</b>, with higher shininess giving a more polished shine and lower factors giving a more diffuse sheen. This final specular factor is then multiplied by the specular colors of the light source and surface, and the result added to the diffuse and ambient colors to give the final color. Non-specular surfaces have a transparent specular color with red, green, blue, and alpha components set to zero, which eliminates the specular term from the shading equation.</p>

<h3>Implementing Phong shading in GLSL</h3>
<p>
Shading calculations are usually performed in the vertex and fragment shaders, where they can leverage the GPU's parallel processing power. (This is where the term "shader" for GPU programs comes from.) Let's bring back the graphics pipeline diagram to get an overview of the Phong shading dataflow:
</p>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl4-pipeline-01.png"></center>
<p>For the best accuracy, we perform shading at a per-fragment level. (For better performance, shading can also be done in the vertex shader and the results interpolated between vertices, but this will lead to less accurate shading, especially for specular effects.) The vertex shader, <a href="http://github.com/jckarter/ch4-flag/blob/master/flag.v.glsl"><tt>flag.v.glsl</tt></a>, thus only performs transformation and projection, using the <tt>p_matrix</tt> and <tt>mv_matrix</tt> we pass in as uniforms. The shader forwards most of the material vertex attributes to varying variables for the fragment shader to use:
</p>
<pre>#version 110

uniform mat4 p_matrix, mv_matrix;
uniform sampler2D texture;

attribute vec3 position, normal;
attribute vec2 texcoord;
attribute float shininess;
attribute vec4 specular;

varying vec3 frag_position, frag_normal;
varying vec2 frag_texcoord;
varying float frag_shininess;
varying vec4 frag_specular;

void main()
{
    vec4 eye_position = mv_matrix * vec4(position, 1.0);
    gl_Position = p_matrix * eye_position;
    frag_position = eye_position.xyz;
    frag_normal   = (mv_matrix * vec4(normal, 0.0)).xyz;
    frag_texcoord = texcoord;
    frag_shininess = shininess;
    frag_specular = specular;
}</pre>
<p>In addition to the texture coordinate, shininess, and specular color, the vertex shader also outputs to the fragment shader the model-view-transformed vertex position. The model-view matrix transforms the coordinate space so that the viewer is at the origin, so we can determine the surface-to-viewer direction needed by the specular calculation from ths transformed position. We likewise transform the normal vector to keep it in the same frame of reference as the position. Since the normal is a directional vector without a position, we apply the matrix to it with a <i>w</i> component of zero, which cancels out the translation of the modelview matrix and only applies its rotation. With this set of varying values, the fragment shader, <a href="http://github.com/jckarter/ch4-flag/blob/master/flag.v.glsl"><tt>flag.f.glsl</tt></a>, can perform the actual Phong calculation:</p>
<pre>#version 110

uniform mat4 p_matrix, mv_matrix;
uniform sampler2D texture;

varying vec3 frag_position, frag_normal;
varying vec2 frag_texcoord;
varying float frag_shininess;
varying vec4 frag_specular;

const vec3 light_direction = vec3(0.408248, -0.816497, 0.408248);
const vec4 light_diffuse = vec4(0.8, 0.8, 0.8, 0.0);
const vec4 light_ambient = vec4(0.2, 0.2, 0.2, 1.0);
const vec4 light_specular = vec4(1.0, 1.0, 1.0, 1.0);

void main()
{
    vec3 mv_light_direction = (mv_matrix * vec4(light_direction, 0.0)).xyz,
         normal = normalize(frag_normal),
         eye = normalize(frag_position),
         reflection = reflect(mv_light_direction, normal);

    vec4 frag_diffuse = texture2D(texture, frag_texcoord);
    vec4 diffuse_factor
        = max(-dot(normal, mv_light_direction), 0.0) * light_diffuse;
    vec4 ambient_diffuse_factor
        = diffuse_factor + light_ambient;
    vec4 specular_factor
        = max(pow(-dot(reflection, eye), frag_shininess), 0.0)
            * light_specular;
    
    gl_FragColor = specular_factor * frag_specular
        + ambient_diffuse_factor * frag_diffuse;
}</pre>
<p>To keep things simple, the shader defines a single light source using <tt>const</tt> values in the shader source. A real renderer would likely feed these light parameters in as uniform values, so that lights can be moved or their material attributes changed from the host program. With the light attributes embedded in the GLSL as constants, it's easy to change the light attributes in the source, press <tt>R</tt> to reload the shader, and see the result. Our light source acts as if it were infinitely far away, shining from the same <tt>light_direction</tt> on every surface in the scene. The light is white, with a 20% baseline ambient light level. It can be made colored by replacing <tt>light_diffuse</tt>, <tt>light_ambient</tt>, <tt>light_specular</tt> with RGBA values.</p>
<p>The fragment shader uses several new GLSL functions we haven't seen before:</p>
<ul>
<li><tt>normalize(v)</tt> returns a unit vector with the same direction as <tt>v</tt>. We use it here to convert the fragment position into a direction vector, and to ensure that the normal is a unit vector. Even if our original vertex normals are all unit vectors, their linear interpolations won't be.</li>
<li><tt>pow(x,n)</tt> raises <tt>x</tt> to the <tt>n</tt>th power, which we use to apply the specular shininess factor.</li>
<li><tt>max(n,m)</tt> returns the larger of <tt>n</tt> or <tt>m</tt>. We use it to clamp dot products less than zero so they shade the same as if they were zero.</li>
<li><img class="figure floated" src="http://duriansoftware.com/joe/media/gl4-reflection-01.png"><tt>reflect(u,v)</tt> reflects the vector <tt>u</tt> around <tt>v</tt>, giving a vector that makes the same angle with <tt>v</tt> as <tt>u</tt>, but in the opposite direction. With it we derive the reflected eye direction for the specular calculation.</li>
</ul>
<p>We transform our constant <tt>light_direction</tt> to put it in the same coordinate space as the <tt>normal</tt> and <tt>eye</tt> vectors. We then sample the surface's diffuse <tt>color</tt> from the mesh texture We assign the shaded value to <tt>gl_FragColor</tt> to generate the final shaded fragment.</p>

<h3>Tweaking the Phong model for stylistic effects</h3>
<p>Before we wrap things up, let's take a quick look at how the Phong framework can be manipulated to give more stylized results. The classic Phong model is a <b>photorealistic</b> model: it attempts to model real-world light behavior. But photorealism isn't always desirable. Many games set themselves apart visually by using more stylized shading effects. These effects often use the basic Phong model of diffuse, ambient, and specular lighting, but they warp the individual factors before summing them together.</p>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl4-diffuse-effects-01.png"></center>
<p>As a trivial example, we can get a brighter, softer shading effect if, instead of clamping the diffuse dot product of back-facing surfaces to zero, we scale it so that perpendicular surfaces receive half illumination, and back-facing surfaces scale linearly toward zero. <i>Team Fortress 2</i> uses this "half Lambert" reflectance scale, so called because the standard Lambertian dropoff rate is halved, as a basis for its cartoonish but semi-photorealistic look (albeit <a href="http://www.valvesoftware.com/publications/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf">heavily modified</a>). Let's modify <tt>flag.f.glsl</tt> to warp the diffuse dot product:
</p>
<pre>float warp_diffuse(float d)
{
    return d * 0.5 + 0.5;
}

void main()
{
    // ...
    vec4 diffuse_factor
        = max(<span class="highlight">warp_diffuse(</span>-dot(normal, mv_light_direction)<span class="highlight">)</span>, 0.0) * light_diffuse;
    // ...
}

</pre>
<center><img src="http://duriansoftware.com/joe/media/gl4-flag-half-lambert-shaded.png"></center>
<p>
A popular effect that builds from this half-Lambert scale is <b>cel shading</b>, in which a stair-step function is applied to the half-Lambert factor so that surfaces are shaded flatly with higher contrast between light and dark areas, in the style of traditional hand-drawn animation cels. <i>Jet Set Radio</i> pioneered this look, and it's since been used in countless games. Implementing it in GLSL is easy:
</p>
<pre>float cel(float d)
{
    return smoothstep(0.35, 0.37, d) * 0.4 + smoothstep(0.70, 0.72, d) * 0.6;
}

float warp_diffuse(float d)
{
    return cel(d * 0.5 + 0.5);
}</pre>
<center><img src="http://duriansoftware.com/joe/media/gl4-flag-cel-shaded.png"></center>
<p>GLSL's <tt>smoothstep(lo,hi,x)</tt> function behaves like this: if <tt>x</tt> is less than <tt>lo</tt>, it returns <tt>0.0</tt>; if greater than <tt>hi</tt>, it returns <tt>1.0</tt>; if in between, it transitions linearly from zero to one. Our <tt>cel</tt> function above uses <tt>smoothstep</tt> to create three flat shading levels with short linear transitions in between.</p>
<p>
There are other effects that can be performed by messing with the <tt>warp_diffuse</tt> function. For example, the function doesn't need to be <tt>float</tt>-to-<tt>float</tt> but could also map to a color scale; you could map greater dot products to warmer reddish colors while lesser products map to cooler bluish colors to give an artistic illustration effect. I encourage you to experiment with the fragment shader code to see what other effects you can create.
</p>
<h3>Conclusion</h3>
<p>With Phong shading implemented, we can start adding additional effects to further improve the look of the flag scene. The most glaring problem is the lack of shadow cast by the flag, so next chapter we'll look at shadow mapping, a technique for rendering accurate shadows into a scene, and learn about off-screen framebuffer objects in the process. Meanwhile, if you're interested in learning more about real-time shading techniques on your own without an OpenGL bias, I highly recommend the book <a href="http://www.realtimerendering.com/"><i>Real-Time Rendering</i></a>.</p>
<h4><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html">&laquo; Chapter 3</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">Table of Contents</a></h4>

</div>
<div class="blog">
<h3><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html">An intro to modern OpenGL. Chapter 3: 3D transformation and projection</a></h3>
<h4>updated July 14, 2010 15:34:17 PDT</h4>
<h4><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html">&laquo; Chapter 2.3</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">Table of Contents</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html">Chapter 4 &raquo;</a></h4>
<p>
The GPU's specialty, and by extension OpenGL's, is in rendering three-dimensional scenes. If you compare <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html">last chapter</a>'s <tt>hello-gl</tt> program to, say, Crysis, you might notice that our demo is missing one of those dimensions (among other things). In this chapter, I'm going to fix that. We'll cover the basic math that makes <span class="smallcap">3d</span> rendering happen, looking at how <b>transformations</b> are done using <b>matrices</b> and how <b>perspective projection</b> works. Wikipedia does a great job going in-depth about the algorithmic details, so I'm going to spend most of my time talking at a high level about what math we use and why, linking to the relevant Wikipedia articles if you're interested in exploring further. As we look at different transformations, we're going to take the vertex shader from last chapter and extend it to implement those transformations, animating the "hello world" image by moving its rectangle around in <span class="smallcap">3d</span> space.
</p>
<p>Before we start, there are some changes we need to make to last chapter's <tt>hello-gl</tt> program so that it's easier to play around with. These changes will allow us to write different vertex shaders and supply them as command-line arguments when we run the program, like so:</p>
<pre>
./hello-gl hello-gl.v.glsl
</pre>
<p>You can pull these changes from my <a href="http://github.com/jckarter/hello-gl-ch3"><tt>hello-gl-ch3</tt> github repo</a>.
</p>
<h3>Updating <tt>hello-gl</tt></h3>
<p>We'll start by expanding our vertex array to hold three-dimensional vectors. We'll actually pad them out to four components&mdash;the fourth component's purpose will become clear soon. For now, we'll just set all the fourth components to one. Let's update our vertex array data in <tt>hello-gl.c</tt>:</p>
<pre>
static const GLfloat g_vertex_buffer_data[] = { 
    <span class="highlight">-1.0f, -1.0f, 0.0f, 1.0f,
     1.0f, -1.0f, 0.0f, 1.0f,
    -1.0f,  1.0f, 0.0f, 1.0f,
     1.0f,  1.0f, 0.0f, 1.0f</span>
};
</pre>
<p>and our <tt>glVertexAttribPointer</tt> call:</p>
<pre>
    glVertexAttribPointer(
        g_resources.attributes.position,  /* attribute */
        <span class="highlight">4</span>,                                /* size */
        GL_FLOAT,                         /* type */
        GL_FALSE,                         /* normalized? */
        <span class="highlight">sizeof(GLfloat)*4</span>,                /* stride */
        (void*)0                          /* array buffer offset */
    );
</pre>
<p>When we start transforming our rectangle, it will no longer completely cover the window, so let's add a <tt>glClear</tt> to our <tt>render</tt> function so we don't get garbage in the background. We'll set it to dark grey so it's distinct from the black background of our images:
<pre>
static void render(void)
{
    <span class="highlight">glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);</span>
    /* ... */
}
</pre>
<p>Now let's generalize a few things. First, we'll change our uniform state to include GLUT's <tt>timer</tt> value directly rather than the <tt>fade_factor</tt> precalculated. This will let our new vertex shaders perform additional time-based effects.</p>
<pre>
static void update_<span class="highlight">timer</span>(void)
{
    int milliseconds = glutGet(GLUT_ELAPSED_TIME);
    g_resources.<span class="highlight">timer</span> = <span class="highlight">(float)milliseconds * 0.001f</span>;
    glutPostRedisplay();
}
</pre>
<p>You'll also have to search-and-replace all of the other references to <tt>fade_factor</tt> with <tt>timer</tt>. Once that's done, we'll change our <tt>main</tt> and <tt>make_resources</tt> functions so they can take the vertex shader filename as an argument. This way, we can easily switch between the different vertex shaders we'll be writing:</p>
<pre>
static int make_resources(<span class="highlight">const char *vertex_shader_file</span>)
{
    /* ... */
    g_resources.vertex_shader = make_shader(
        GL_VERTEX_SHADER,
        <span class="highlight">vertex_shader_file</span>
    );
    /* ... */
}
</pre>
<pre>
int main(int argc, char** argv)
{
    /* ... */
    if (!make_resources(<span class="highlight">argc >= 2 ? argv[1] : "hello-gl.v.glsl"</span>)) {
        fprintf(stderr, "Failed to load resources\n");
        return 1;
    }
    /* ... */
}
</pre>
<p>Now let's update our shaders to match our changes to the uniform state and vertex array. We can move the fade factor calculation into the vertex shader, which will pass it on to the fragment shader as a <tt>varying</tt> value. In <tt>hello-gl.v.glsl</tt>:</p>
<pre>
#version 110

<span class="highlight">uniform float timer;</span>

attribute <span class="highlight">vec4</span> position;

varying vec2 texcoord;
<span class="highlight">varying float fade_factor;</span>

void main()
{
    gl_Position = <span class="highlight">position</span>;
    texcoord = position<span class="highlight">.xy</span> * vec2(0.5) + vec2(0.5);
    <span class="highlight">fade_factor = sin(timer) * 0.5 + 0.5;</span>
}
</pre>
<p>A new feature of GLSL I use here is vector <b>swizzling</b>: not only can you address the components of a <tt>vec</tt> type as if they were struct fields by using <tt>.x</tt>, <tt>.y</tt>, <tt>.z</tt>, and <tt>.w</tt> for the first through fourth components, you can also string together the element letters to collect multiple components in any order into a longer or shorter vector type. <tt>position.xy</tt> picks out as a <tt>vec2</tt> the first two elements of our now four-component <tt>position</tt> vector. We can then feed that <tt>vec2</tt> into the calculation for our <tt>texcoord</tt>, which remains two components long.
</p>
<p>Finally, in <tt>hello-gl.f.glsl</tt>, we make <tt>fade_factor</tt> assume its new <tt>varying</tt> identity:</p>
<pre>
#version 110

uniform sampler2D textures[2];

<span class="highlight">varying</span> float fade_factor;
varying vec2 texcoord;

void main()
{
    gl_FragColor = mix(
        texture2D(textures[0], texcoord),
        texture2D(textures[1], texcoord),
        fade_factor
    );
}
</pre>
<p><a name="gl3-math-part">With those changes out of the way, we can recompile the executable once and not have to mess with C any more for the rest of the chapter. We can write new vertex shader files and execute them using <tt>./hello-gl vertex-shader.v.glsl</tt> without recompiling anything. Now we're ready do some math!</a></p>
<h3>Projection and world space</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-projection-space-01.png">
<p>The destination space for the vertex shader, which I've been informally referring to as "screen space" in the last couple of chapters, is more precisely called <b>projection space</b>. The visible part of projection space is the unit-radius cube from (&ndash;1, &ndash;1, &ndash;1) to (1, 1, 1). Anything outside of this cube gets <b>clipped</b> and thrown out. The <i>x</i> and <i>y</i> axes map across the <b>viewport</b>, the part of the screen in which any rendered output will be displayed, with (&ndash;1, &ndash;1, <i>z</i>) corresponding to the lower left corner, (1, 1, <i>z</i>) to the upper right, and (0, 0, <i>z</i>) to the center. The rasterizer uses the <i>z</i> coordinate to assign a depth value to every fragment it generates; if the framebuffer has a depth buffer, these depth values can be compared against the depth values of previously rendered fragments, allowing parts of newly-rendered objects to be hidden behind objects that have already been rendered into the framebuffer. (<i>x</i>, <i>y</i>, &ndash;1) is the <b>near plane</b> and maps to the nearest depth value. At the other end, (<i>x</i>, <i>y</i>, 1) is the <b>far plane</b> and maps to the farthest depth value. Fragments with <i>z</i> coordinates outside of that range get clipped against these planes just like they do the edges of the screen.</p>
<p>Projection space is computationally convenient for the GPU, but it's not very usable by itself for modeling vertices within a scene. Rather than input projection-space vertices directly to the pipeline, most programs use the vertex shader to <b>project</b> objects into it. The pre-projection coordinate system used by the program is called <b>world space</b>, and can be moved, scaled, and rotated relative to projection space in whatever way the program needs. Within world space, objects also need to move around, changing position, orientation, size, and shape. Both of these operations, mapping world space to projection space and positioning objects in world space, are accomplished by performing <b>transformations</b> with mathematical structures called <b>matrices</b>.</p>
<h3>Linear transformations with matrices</h3>
<p>
<a href="http://en.wikipedia.org/wiki/Linear_transformation"><b>Linear transformations</b></a> are operations on an object that preserve the relative size and orientation of parts within the object while uniformly changing its overall size or orientation. They include <b>rotation</b>, <b>scaling</b>, and <b>shearing</b>. If you've ever used the "free transform" tool in Photoshop or GIMP, these are the sorts of transformations it performs. You can think of a linear transformation as taking the <i>x</i>, <i>y</i>, and <i>z</i> axes of your coordinate space and mapping them to a new set of arbitrary axes <i>x'</i>, <i>y'</i>, and <i>z'</i>:
</p>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl3-linear-transformation-matrices-01.png"></center>
<p>
For clarity, the figure is two-dimensional, but the same idea applies to <span class="smallcap">3d</span>. To represent a linear transformation numerically, we can take the vector values of those new axes and arrange them into a 3&#xd7;3 <b>matrix</b>. We can then perform an operation called <a href="http://en.wikipedia.org/wiki/Matrix_multiplication"><b>matrix multiplication</b></a> to apply a linear transformation to a vector, or to combine two transformations into a single matrix that represents the combined transformation. In standard mathematical notation, matrices are represented so that the axes are represented as columns going left-to-right. In GLSL and in the OpenGL API, matrices are represented as an array of vectors, each vector representing a column in the matrix. In source code, this results in the values looking transposed from their mathematical notation. This is called <b>column-major order</b> (as opposed to row-major order, in which each vector element of the matrix array would be a row of the matrix). GLSL provides 2&#xd7;2, 3&#xd7;3, and 4&#xd7;4 matrix types named <tt>mat2</tt> through <tt>mat4</tt>. It also overloads its multiplication operator for use between <tt>mat<i>n</i></tt> values of the same type, and between <tt>mat<i>n</i></tt>s and <tt>vec<i>n</i></tt>s, to perform matrix-matrix and matrix-vector multiplication.
</p>
<p>A nice property of linear transformations is that they work well with the rasterizer's linear interpolation. If we transform all of the vertices of a triangle using the same linear transformation, every point on its surface will retain its relative position to the vertices, so textures and other varying values will transform with the vertices they fill out.
<p>
Note that all linear transformations occur relative to the <b>origin</b>, that is, the (0, 0, 0) point of the coordinate system, which remains constant through a linear transformation. Because of this, moving an object around in space, called <b>translation</b> in mathematical terms, is <i>not</i> a linear transformation, and cannot be represented with a 3&#xd7;3 matrix or composed into other 3&#xd7;3 linear transform matrices. We'll see how to integrate translation into transformation matrices shortly. For now, let's try some linear transformations:
</p>
<h3>Rotation</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-rotation-matrix-01.png">
<p>
We'll start by writing a shader that spins our rectangle around the <i>z</i> axis. Using the <tt>timer</tt> uniform value as a rotation angle, we'll construct a <a href="http://en.wikipedia.org/wiki/Rotation_matrix">rotation matrix</a>, using the <tt>sin</tt> and <tt>cos</tt> functions to rotate our matrix axes around the unit circle. The shader looks like this; it's in the repo as <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/rotation.v.glsl"><tt>rotation.v.glsl</tt></a>:
</p>
<pre>
#version 110

uniform float timer;

attribute vec4 position;

varying vec2 texcoord;
varying float fade_factor;

void main()
{
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    gl_Position = vec4(rotation * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
}
</pre>
<p>(I'm going to be listing only the <tt>main</tt> function of the next few shaders; the <tt>uniform</tt>, <tt>attribute</tt>, and <tt>varying</tt> declarations will all remain the same from here.) With our changes to <tt>hello-gl</tt> we can run it like so:</p>
<pre>
./hello-gl rotation.v.glsl
</pre>
<p>And this is the result:</p>
<center><img src="http://duriansoftware.com/joe/media/gl3-rotation-screenshot.png"></center>
<p>
<h3>Scaling to fit the aspect ratio</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-scaling-matrix-01.png">
<p>
You probably noticed that the rectangle appears to be horizontally distorted as it rotates. This is because our window is wider than it is tall, so the screen distance covered along a unit on the <i>x</i> axis of projection space is longer than the distance the same unit would cover along the <i>y</i> axis. The window is 400 pixels wide and 300 pixels high, giving it an <b>aspect ratio</b> of 4:3 (the width divided by the height). (This will change if we resize the window, but we won't worry about that for now.) We can compensate for this by applying a <a href="http://en.wikipedia.org/wiki/Scaling_(geometry)#Matrix_representation">scaling matrix</a> that scales the <i>x</i> axis by the reciprocal of the aspect ratio, as in <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/window-scaled-rotation.v.glsl"><tt>window-scaled-rotation.v.glsl</tt></a>:
</p>
<pre>
    mat3 window_scale = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    gl_Position = vec4(window_scale * rotation * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
</pre>
<p><img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-matrix-order-01.png">Note that the order in which we rotate and scale is important. Unlike scalar multiplication, matrix multiplication is <i>noncommutative</i>: Changing the order of the arguments gives different results. This should make intuitive sense: "rotate an object, then squish it horizontally" gives a different result from "squish an object horizontally, then rotate it". As matrix math, you write transformation sequences out right-to-left, backwards compared to English: <tt>scale * rotate * vector</tt> rotates the vector first, whereas <tt>rotate * scale * vector</tt> scales first.</p>
<center><img src="http://duriansoftware.com/joe/media/gl3-window-scale-rotation-screenshot.png"></center>
<p>Now that we've compensated for the distortion of our window's projection space, we've revealed a dirty secret. Our input rectangle is really a square, and it doesn't match the aspect ratio of our image, leaving it scrunched. We need to scale it again outward, this time <i>before</i> we rotate, as in <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/window-object-scaled-rotation.v.glsl"><tt>window-object-scaled-rotation.v.glsl</tt></a>:
<pre>
    mat3 window_scale = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    mat3 rotation = mat3(
        vec3( cos(timer),  sin(timer),  0.0),
        vec3(-sin(timer),  cos(timer),  0.0),
        vec3(        0.0,         0.0,  1.0)
    );
    mat3 object_scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    gl_Position = vec4(window_scale * rotation * object_scale * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
</pre>
<p>(Alternately, we could change our vertex array and apply a scaling transformation to our generated <tt>texcoord</tt>s. But I promised we wouldn't be changing the C anymore in this chapter.)</p> With this shader, our rectangle now rotates the way we would expect it to:</p>
<center><img src="http://duriansoftware.com/joe/media/gl3-window-object-scale-rotation-screenshot.png"></center>

<h3>Projection and model-view matrices</h3>
<p>The <tt>window_scale</tt> matrix conceptually serves a different purpose from the <tt>rotation</tt> and <tt>object_scale</tt> matrices. While the latter two matrices set up our input vertices to be where we want them in world space, the <tt>window_scale</tt> serves to project world space into projection space in a way that gives an undistorted final render. Matrices used to orient objects in world space, like our <tt>rotation</tt> and <tt>object_scale</tt> matrices, are called <b>model-view matrices</b>, because they are used both to transform models and to position them relative to the viewport. The matrix we use to project, in this case <tt>window_scale</tt>, is called the <b>projection matrix</b>. Although both kinds of matrix behave the same, and the line drawn between them is mathematically arbitrary, the distinction is useful because a <span class="smallcap">3d</span> application will generally only need a few projection matrices that change rarely (usually only if the window size or screen resolution changes). On the other hand, there can be countless model-view matrices for all of the objects in a scene, which will update constantly as the objects animate.

<h3>Orthographic and perspective projection</h3>
<p>Projecting with a scaling matrix, as we're doing here, produces an <a href="http://en.wikipedia.org/wiki/Orthographic_projection">orthographic projection</a>, in which objects in <span class="smallcap">3d</span> space are rendered at a constant scale regardless of their distance from the viewport. Orthographic projections are useful for rendering two-dimensional display elements, such as the UI controls of a game or graphics tool, and in modeling applications where the artist needs to see the exact scales of different parts of a model, but they don't adequately present <span class="smallcap">3d</span> scenes in a way most viewers expect. To demonstrate this, let's break out of the <span class="smallcap">2d</span> plane and alter our shader to rotate the rectangle around the <i>x</i> axis, as in <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/orthographic-rotation.v.glsl"><tt>orthographic-rotation.v.glsl</tt></a>:</p>
<pre>
    const mat3 projection = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );

    mat3 rotation = mat3(
        vec3(1.0,         0.0,         0.0),
        vec3(0.0,  cos(timer),  sin(timer)),
        vec3(0.0, -sin(timer),  cos(timer))
    );
    mat3 scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );
    gl_Position = vec4(projection * rotation * scale * position.xyz, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
</pre>
<center><img src="http://duriansoftware.com/joe/media/gl3-orthographic-rotation-screenshot.png"></center>
<p>With an orthographic projection, the rectangle doesn't very convincingly rotate in <span class="smallcap">3d</span> space&mdash;it just sort of accordions up and down. This is because the top and bottom edges of the rectangle remain the same apparent size as they move toward and away from the view. In the real world, objects appear smaller in our field of view proportional to how far from our eyes they are. This effect is called <b>perspective</b>, and transforming objects to take perspective into account is called <a href="http://en.wikipedia.org/wiki/3D_projection#Perspective_projection"><b>perspective projection</b>.</a> Perspective projection is accomplished by shrinking objects proportionally to their distance from the "eye". An easy way to do this is to divide each point's position by some function of its <i>z</i> coordinate. Let's arbitrarily decide that zero on the <i>z</i> axis remains unscaled, and that points elsewhere on the <i>z</i> axis scale by half their distance from zero. Correspondingly, let's also scale the <i>z</i> axis by half, so that the end of the rectangle coming toward us doesn't get clipped to the near plane as it gets magnified. We'll end up with the shader code in <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/naive-perspective-rotation.v.glsl"><tt>naive-perspective-rotation.v.glsl</tt></a>:
<pre>
    const mat3 projection = mat3(
        vec3(3.0/4.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 0.5)
    );

    mat3 rotation = mat3(
        vec3(1.0,         0.0,         0.0),
        vec3(0.0,  cos(timer),  sin(timer)),
        vec3(0.0, -sin(timer),  cos(timer))
    );
    mat3 scale = mat3(
        vec3(4.0/3.0, 0.0, 0.0),
        vec3(    0.0, 1.0, 0.0),
        vec3(    0.0, 0.0, 1.0)
    );

    vec3 projected_position = projection * rotation * scale * position.xyz;
    float perspective_factor = projected_position.z * 0.5 + 1.0;

    gl_Position = vec4(projected_position/perspective_factor, 1.0);
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
</pre>
<center><img src="http://duriansoftware.com/joe/media/gl3-naive-perspective-screenshot.png"></center>
<p>Now the overall shape of the rectangle appears to rotate in perspective, but the texture mapping is all kinky. This is because perspective projection is a <i>nonlinear</i> transformation&mdash;different parts of the rectangle get scaled differently depending on how far away they are. This interferes with the linear interpolation the rasterizer applies to the texture coordinates across the surface of our triangles. To properly project texture coordinates as well as other varying values in perspective, we need a different approach that takes the rasterizer into account.</p>

<h3>Homogeneous coordinates</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-homogeneous-coordinates-01.png">
<p>Directly applying perspective to an object may not be a linear transformation, but the divisor that perspective applies is a linear function of the perspective distance. If we stored the divisor out-of-band as an extra component of our vectors, we could apply perspective as a matrix transformation, and the rasterizer could linearly interpolate texture coordinates correctly before the perspective divisor is applied. This is in fact what that mysterious 1.0 we've been sticking in the fourth component of our vectors is for. The projection space that <tt>gl_Position</tt> addresses uses <a href="http://en.wikipedia.org/wiki/Homogeneous_coordinates"><b>homogeneous coordinates</b></a>. That fourth component, labeled <i>w</i>, divides the <i>x</i>, <i>y</i>, and <i>z</i> components when the coordinate is projected. In other words, the homogeneous coordinate [<i>x</i>:<i>y</i>:<i>z</i>:<i>w</i>] projects to the linear coordinate (<i>x</i>/<i>w</i>, <i>y</i>/<i>w</i>, <i>z</i>/<i>w</i>). 
</p>
<p>
With this trick, we can construct a <b>perspective matrix</b> that maps distances on the <i>z</i> axis to scales on the <i>w</i> axis. As I mentioned, the rasterizer also interpolates varying values in homogeneous space, before the coordinates are projected, so texture coordinates and other varying values will blend correctly over perspective-projected triangles using this matrix. The 3&#xd7;3 linear transformation matrices we've covered extend to 4&#xd7;4 easily&mdash;just extend the columns to four components and add a fourth column that leaves the <i>w</i> axis unchanged. Let's update our vertex shader to use a proper perspective matrix and <tt>mat4</tt>s to transform our rectangle, as in <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/perspective-rotation.v.glsl"><tt>perspective-rotation.v.glsl</tt></a>:
</p>
<pre>
    const mat4 projection = mat4(
        vec4(3.0/4.0, 0.0, 0.0, 0.0),
        vec4(    0.0, 1.0, 0.0, 0.0),
        vec4(    0.0, 0.0, 0.5, 0.5),
        vec4(    0.0, 0.0, 0.0, 1.0)
    );

    mat4 rotation = mat4(
        vec4(1.0,         0.0,         0.0, 0.0),
        vec4(0.0,  cos(timer),  sin(timer), 0.0),
        vec4(0.0, -sin(timer),  cos(timer), 0.0),
        vec4(0.0,         0.0,         0.0, 1.0)
    );
    mat4 scale = mat4(
        vec4(4.0/3.0, 0.0, 0.0, 0.0),
        vec4(    0.0, 1.0, 0.0, 0.0),
        vec4(    0.0, 0.0, 1.0, 0.0),
        vec4(    0.0, 0.0, 0.0, 1.0)
    );

    gl_Position = projection * rotation * scale * position;
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
</pre>
<center><img src="http://duriansoftware.com/joe/media/gl3-perspective-screenshot.png"></center>
<p>The texture coordinates now project correctly with the rectangle as it rotates in perspective.</p>

<h3>Affine transformations</h3>
<img class="figure floated" src="http://duriansoftware.com/joe/media/gl3-translation-matrix-01.png">
<p>
Homogeneous coordinates let us pull another trick using 4&#xd7;4 matrices. Earlier, I noted that translation cannot be represented in a 3&#xd7;3 linear transformation matrix. While translation can be achieved by simple vector addition, combinations of translations and linear transformations can't be easily composed that way. However, by using the <i>w</i> axis column of a 4&#xd7;4 matrix to map the <i>w</i> axis value back onto the <i>x</i>, <i>y</i>, and <i>z</i> axes, we can set up a <b>translation matrix</b>. The combination of a linear transformation with a translation is referred to as an <b>affine transformation</b>. Like our 3&#xd7;3 linear transformation matrices, 4&#xd7;4 affine transformation matrices can be multiplied together to give new matrices combining their transformations.
</p>

<h3>Constructing a view frustum matrix</h3>
<p>The perspective projection matrix we constructed above gets the job done, but it's a bit ad-hoc. An easier to understand way of projecting world space would be to consider the origin to be the camera position and project from there. Now that we know how to make translation matrices, we can leave the model-view matrix to position the camera in world space. Different programs will also want to control the <a href="http://en.wikipedia.org/wiki/Angle_of_view"><b>angle of view</b></a> (<i>&alpha;</i>) of the projection, and the distance of the near (<i>z<sub>n</sub></i>) and far (<i>z<sub>f</sub></i>) planes in world space. A narrower angle of view will project a far-away object to a scale more similar to close objects, giving a zoomed-in effect, while a wider angle makes objects shrink more relative to their distance, giving a wider field of view. The ratio between the near and far planes affects the resolution of the depth buffer. If the planes are too far apart, or the near plane too close to zero, you'll get <b>z-fighting</b>, where the <i>z</i> coordinates of projected triangles differ by less than the depth buffer can represent, and depth testing gives invalid results, causing nearby objects to "fight" for pixels along their shared edge.</p>
<center><img class="figure" src="http://duriansoftware.com/joe/media/gl3-view-frustum-01.png"></center>
<p>From these variables, we can come up with a general function to construct a projection matrix for any <b><a href="http://en.wikipedia.org/wiki/View_frustum">view frustum</a></b>. The math is a little hairy; I'll describe what it does in broad strokes. With the camera at the origin, we can project the <i>z</i> axis directly to <i>w</i> axis values.  In an affine transformation matrix, the bottom row is always set to [0 0 0 1]. This leaves the <i>w</i> axis unchanged. Changing this bottom row will cause the <i>x</i>, <i>y</i>, or <i>z</i> axis values to project onto the <i>w</i> axis, giving a perspective effect along the specified axis. In our case, setting that last row to [0 0 1 0] projects the <i>z</i> axis value directly to the perspective scale on <i>w</i>.</p>
<p>We'll then need to remap the range on the <i>z</i> axis from <i>z<sub>n</sub></i> to <i>z<sub>f</sub></i> so that it projects into the space between the near (&ndash;1) and far (1) planes of projection space. Taking the effect of the <i>w</i> coordinate into account, we'll have to map into the range from &ndash;<i>z<sub>n</sub></i> (which with a <i>w</i> coordinate of <i>z<sub>n</sub></i> will project to &ndash;1) to <i>z<sub>f</sub></i> (which with a <i>w</i> coordinate that's also <i>z<sub>f</sub></i> will project to 1). We do this by translating and scaling the <i>z</i> axis to fit this new range. The angle of view is determined by how much we scale the <i>x</i> and <i>y</i> axes. A scale of one gives a 45&deg; angle of view; shrinking the axes gives a wider field of view, and growing them gives a narrower field, inversely proportional to the tangent of the angle of view. So that our output isn't distorted, we also scale the <i>y</i> axis proportionally to the aspect ratio (<i>r</i>) of the viewport.
</p>
<p>
Let's write one last shader using the view frustum matrix function. We'll translate the rectangle to set it 3 units in front of us. In addition to rotating around the <i>x</i> axis, we'll also change the translation over time to set it moving in a circle left to right and toward and away from us. Here's the code, from <a href="http://github.com/jckarter/hello-gl-ch3/blob/master/view-frustum-rotation.v.glsl"><tt>view-frustum-rotation.v.glsl</tt></a>:</p>
<pre>
#version 110

uniform float timer;

attribute vec4 position;

varying vec2 texcoord;
varying float fade_factor;

mat4 view_frustum(
    float angle_of_view,
    float aspect_ratio,
    float z_near,
    float z_far
) {
    return mat4(
        vec4(1.0/tan(angle_of_view),           0.0, 0.0, 0.0),
        vec4(0.0, aspect_ratio/tan(angle_of_view),  0.0, 0.0),
        vec4(0.0, 0.0,    (z_far+z_near)/(z_far-z_near), 1.0),
        vec4(0.0, 0.0, -2.0*z_far*z_near/(z_far-z_near), 0.0)
    );
}

mat4 scale(float x, float y, float z)
{
    return mat4(
        vec4(x,   0.0, 0.0, 0.0),
        vec4(0.0, y,   0.0, 0.0),
        vec4(0.0, 0.0, z,   0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

mat4 translate(float x, float y, float z)
{
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(x,   y,   z,   1.0)
    );
}

mat4 rotate_x(float theta)
{
    return mat4(
        vec4(1.0,         0.0,         0.0, 0.0),
        vec4(0.0,  cos(timer),  sin(timer), 0.0),
        vec4(0.0, -sin(timer),  cos(timer), 0.0),
        vec4(0.0,         0.0,         0.0, 1.0)
    );
}

void main()
{
    gl_Position = view_frustum(radians(45.0), 4.0/3.0, 0.5, 5.0)
        * translate(cos(timer), 0.0, 3.0+sin(timer))
        * rotate_x(timer)
        * scale(4.0/3.0, 1.0, 1.0)
        * position;
    texcoord = position.xy * vec2(0.5) + vec2(0.5);
    fade_factor = sin(timer) * 0.5 + 0.5;
}
</pre>
<p>And this is what we get:</p>
<center><img src="http://duriansoftware.com/joe/media/gl3-view-frustum-projection-screenshot.png"></center>
<h3>Conclusion</h3>
<p>
Matrix multiplication is by far the most common operation in a <span class="smallcap">3d</span> rendering pipeline. The rotation, scaling, translation, and frustum matrices we've covered are the basic structures that make <span class="smallcap">3d</span> graphics happen. With these fundamentals covered, we're now ready to start building <span class="smallcap">3d</span> scenes. If you want to learn more about <span class="smallcap">3d</span> math, the book <a href="http://www.amazon.com/Primer-Graphics-Development-Wordware-Library/dp/1556229119"><i><span class="smallcap">3d</span> Math Primer for Graphics and Game Development</i></a> gives excellent in-depth coverage beyond the basics I've touched on here.
</p>
<p>In this chapter, I've been demonstrating matrix math by writing code completely within the vertex shader. Constructing our matrices in the vertex shader will cause the matrices to be redundantly calculated for every single vertex. For this simple four-vertex program, it's not a big deal; I stuck to GLSL because it has great support for matrix math built into the language, and demonstrating both the concepts of matrix math and a hoary C math library would make things even more confusing. Unfortunately, OpenGL provides no matrix or vector math through the C API, so we'd need to use a third-party library, such as <a href="http://simdx86.sourceforge.net/">libSIMDx86</a>, to perform this math outside of shaders. In a real program with potentially thousands of vertices, the extra matrix math overhead in the vertex shader will add up. Projection matrices generally apply to an entire scene and only need to be recalculated when the window is resized or the screen resolution changed, and model-view matrices usually change only between frames and apply to sets of vertices, so it is more efficient to precalculate these matrices and feed them to the shader as <tt>uniform</tt>s or <tt>attribute</tt>s. This is how we'll do things from now on.</p>
<p>In the next chapter, we'll leave this lame "hello world" program behind and write a program that renders a more sophisticated <span class="smallcap">3d</span> scene. In the process, we'll look at the next most important aspect of <span class="smallcap">3d</span> rendering after transformation and projection: lighting.
</p>
<h4><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html">&laquo; Chapter 2.3</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">Table of Contents</a> | <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html">Chapter 4 &raquo;</a></h4>

</div>
<div class="blog">
<h3><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">An intro to modern OpenGL. Table of Contents</a></h3>
<h4>updated July 14, 2010 15:33:27 PDT</h4>
<p>
To make it easier for people jumping into my OpenGL tutorial from the middle, I'm going to keep this post up to date with the new articles as I post them.
</p>
<ul>
<li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html">Chapter 1: The Graphics Pipeline</a></li>
<li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2:-Hello-World:-The-Slideshow.html">Chapter 2: Hello World: The Slideshow</a></li>
    <ul>
    <li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html">Chapter 2.1: Buffers and Textures</a></li>
    <li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.2:-Shaders.html">Chapter 2.2: Shaders</a></li>
    <li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html">Chapter 2.3: Rendering</a></li>
    </ul>
<li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-3:-3D-transformation-and-projection.html">Chapter 3: 3D transformation and projection</a></li>
<li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html">Chapter 4: Rendering a Dynamic Scene with Phong Shading</a></li>
</ul>

</div>
<div class="blog">
<h3><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL,-in-Chinese.html">An intro to modern OpenGL, in Chinese</a></h3>
<h4>updated April 25, 2010 19:25:51 PDT</h4>
<p>
<a href="http://blog.csdn.net/kangsongrui/">Kang Songrui</a> is in the process of translating my <a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html">intro to modern OpenGL</a> articles to Chinese. He recently posted his translation of the <a href="http://blog.csdn.net/kangsongrui/archive/2010/04/25/5527508.aspx">first chapter</a>.
</p>
<p>
As for chapter 4 of the English tutorial, rest assured it's coming. I've had money-making-related projects getting in the way.
</p>

</div>

<div class="cleared"></div>
<br><script>male_to('com', 'joe', 'duriansoftware', 'Email me')</script>
<br><a class="archives" href="archives.html">Archives</a>

<div style="clear:both"></div>
</div>

<div class="fineprint">
&copy; 2012 Durian Software. | <a href="../contact.html">Contact Us</a>
</div>
</body>
</html>
